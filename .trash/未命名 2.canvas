{
	"nodes":[
		{"id":"940b47bf20330465","x":-125,"y":-30,"width":585,"height":290,"type":"text","text":"import os\nimport subprocess\nimport ssl\nimport datetime\nimport json\nimport shutil\nimport stat\nimport time\nimport http.server\nimport socketserver\nimport threading\nimport socket\nfrom functools import wraps\nfrom flask import Flask, render_template, request, send_file, redirect, url_for, jsonify, session, make_response\nfrom werkzeug.utils import secure_filename\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom urllib.parse import quote\n\napp = Flask(__name__)\napp.config['CA_DIR'] = 'ca'\napp.config['CERTS_DIR'] = 'certs'\napp.config['UPLOAD_DIR'] = 'uploads'\napp.config['BASE_DIR'] = os.path.abspath(os.path.dirname(__file__))\napp.config['SECRET_KEY'] = os.urandom(24)  # 用于session加密\n\n# 从JSON文件加载用户数据\ndef load_users():\n    try:\n        with open('users.json', 'r', encoding='utf-8') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        # 如果文件不存在，创建默认用户\n        default_users = {\n            'admin': {\n                'password': generate_password_hash('admin123'),\n                'role': 'admin'\n            }\n        }\n        save_users(default_users)\n        return default_users\n\ndef save_users(users):\n    users_file = os.path.join(app.config['BASE_DIR'], 'users.json')\n    with open(users_file, 'w', encoding='utf-8') as f:\n        json.dump(users, f, ensure_ascii=False, indent=4)\n\n# 初始化用户数据\nUSERS = load_users()\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'username' not in session:\n            return redirect(url_for('login'))\n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        remember = request.form.get('remember')\n        \n        if username in USERS and check_password_hash(USERS[username]['password'], password):\n            session['username'] = username\n            response = make_response(redirect(url_for('index')))\n            \n            if remember:  # 如果选择了\"记住我\"，设置30天的cookie\n                session.permanent = True\n                app.permanent_session_lifetime = datetime.timedelta(days=30)\n            \n            return response\n        \n        return render_template('login.html', error='用户名或密码错误')\n    \n    return render_template('login.html')\n\n@app.route('/logout')\ndef logout():\n    session.clear()\n    return redirect(url_for('login'))\n\n@app.route('/settings', methods=['GET', 'POST'])\n@login_required\ndef settings():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        old_password = request.form.get('old_password')\n        new_password = request.form.get('new_password')\n        \n        # 验证原密码\n        if not check_password_hash(USERS[session['username']]['password'], old_password):\n            return render_template('settings.html', username=session['username'], error='原密码错误')\n        \n        # 更新用户名和密码\n        old_username = session['username']\n        USERS[username] = USERS.pop(old_username)  # 更新用户名（键值）\n        USERS[username]['password'] = generate_password_hash(new_password)  # 更新密码\n        save_users(USERS)  # 保存更新后的用户信息到文件\n        session['username'] = username  # 更新session中的用户名\n        return render_template('settings.html', username=username, success='用户信息更新成功')\n    \n    return render_template('settings.html', username=session['username'])\n\n# 初始化目录\nos.makedirs(app.config['CA_DIR'], exist_ok=True)\nos.makedirs(app.config['CERTS_DIR'], exist_ok=True)\nos.makedirs(app.config['UPLOAD_DIR'], exist_ok=True)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'success': False, 'message': '没有文件被上传'})\n    \n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'success': False, 'message': '没有选择文件'})\n    \n    if file:\n        filename = secure_filename(file.filename)\n        file_path = os.path.join(app.config['UPLOAD_DIR'], filename)\n        file.save(file_path)\n        return jsonify({'success': True, 'filename': filename})\n\ndef generate_ca(org_name=None, password=None):\n    # 使用相对路径\n    ca_dir = app.config['CA_DIR']\n    ca_key = os.path.join(ca_dir, 'qilin-ca.key')\n    ca_crt = os.path.join(ca_dir, 'qilin-ca.crt')\n    ca_info_file = os.path.join(ca_dir, 'ca_info.json')\n    \n    print(f\"CA目录: {ca_dir}\")\n    print(f\"CA密钥路径: {ca_key}\")\n    print(f\"CA证书路径: {ca_crt}\")\n    \n    # 确保CA目录存在\n    os.makedirs(ca_dir, exist_ok=True)\n    \n    # 如果没有提供机构名称，使用默认值\n    if not org_name:\n        org_name = \"qilin SSL CA\"\n    \n    try:\n        # 直接使用系统openssl命令\n        openssl_cmd = 'openssl'\n        print(f\"使用系统OpenSSL: {openssl_cmd}\")\n        config_param = []\n        \n        # 生成 CA 私钥\n        print(\"开始生成CA私钥...\")\n        if password:\n            # 使用密码保护私钥\n            key_cmd = [\n                openssl_cmd, 'genrsa', '-des3', '-passout', f'pass:{password}',\n                '-out', ca_key, '4096'\n            ]\n            result = subprocess.run(key_cmd, capture_output=True, text=True, check=True)\n            print(f\"私钥生成结果: {result.stdout}\")\n        else:\n            # 不使用密码\n            key_cmd = [\n                openssl_cmd, 'genrsa', '-out', ca_key, '4096'\n            ]\n            result = subprocess.run(key_cmd, capture_output=True, text=True, check=True)\n            print(f\"私钥生成结果: {result.stdout}\")\n\n        # 检查私钥文件是否生成\n        if not os.path.exists(ca_key):\n            raise Exception(f\"CA私钥文件未生成: {ca_key}\")\n        else:\n            print(f\"CA私钥文件已生成: {ca_key}\")\n\n        # 生成 CA 根证书\n        print(\"开始生成CA根证书...\")\n        req_cmd = [\n            openssl_cmd, 'req', '-config', '/etc/ssl/openssl.cnf', '-x509', '-new', '-nodes',\n            '-key', ca_key, '-sha256', '-days', '3650',\n            '-out', ca_crt,\n            '-subj', f'/C=CN/ST=Guangdong/L=Shenzhen/O={org_name}/OU=Certificate Authority Department/CN={org_name}/emailAddress=ca@qilin-ssl.com'\n        ]\n        \n        # 如果设置了密码，添加密码参数\n        if password:\n            req_cmd.extend(['-passin', f'pass:{password}'])\n        \n        print(f\"执行命令: {' '.join(req_cmd)}\")\n        result = subprocess.run(req_cmd, capture_output=True, text=True, check=True)\n        print(f\"证书生成结果: {result.stdout}\")\n        \n        # 检查证书文件是否生成\n        if not os.path.exists(ca_crt):\n            raise Exception(f\"CA证书文件未生成: {ca_crt}\")\n        else:\n            print(f\"CA证书文件已生成: {ca_crt}\")\n        \n        # 保存CA证书信息\n        ca_info = {\n            'org_name': org_name,\n            'created_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'valid_until': (datetime.datetime.now() + datetime.timedelta(days=3650)).strftime('%Y-%m-%d'),\n            'has_password': bool(password)\n        }\n        \n        with open(ca_info_file, 'w', encoding='utf-8') as f:\n            json.dump(ca_info, f, ensure_ascii=False)\n        \n        print(f\"CA信息文件已保存: {ca_info_file}\")\n        return ca_key, ca_crt, ca_info\n    \n    except subprocess.CalledProcessError as e:\n        error_msg = f\"执行OpenSSL命令失败: {str(e)}\"\n        if e.stderr:\n            error_msg += f\"\\n错误输出: {e.stderr}\"\n        print(error_msg)\n        raise Exception(error_msg)\n    except Exception as e:\n        print(f\"生成CA证书时出错: {str(e)}\")\n        raise\n\n@app.route('/')\n@login_required\ndef index():\n    # 检查是否存在CA证书信息\n    ca_info_file = os.path.join(app.config['CA_DIR'], 'ca_info.json')\n    ca_info = None\n    \n    if os.path.exists(ca_info_file):\n        with open(ca_info_file, 'r', encoding='utf-8') as f:\n            ca_info = json.load(f)\n    \n    return render_template('index.html', ca_info=ca_info)\n\n@app.route('/verify')\n@login_required\ndef verify():\n    return render_template('verify.html')\n\n@app.route('/proxy')\n@login_required\ndef proxy():\n    return render_template('proxy.html')\n\n@app.route('/tutorial')\n@login_required\ndef tutorial():\n    return render_template('tutorial.html')\n\n@app.route('/about')\n@login_required\ndef about():\n    return render_template('about.html')\n\n@app.route('/create_ca', methods=['POST'])\ndef create_ca():\n    # 获取用户输入\n    org_name = request.form.get('org_name', '')\n    password = request.form.get('password', '')\n    \n    # 如果org_name为空，使用默认值\n    if not org_name:\n        org_name = \"qilin SSL CA\"\n    \n    # 如果password为空，则不使用密码\n    if not password:\n        password = None\n    \n    try:\n        # 删除现有的CA证书（如果存在）\n        ca_dir = os.path.abspath(app.config['CA_DIR'])\n        ca_key = os.path.join(ca_dir, 'qilin-ca.key')\n        ca_crt = os.path.join(ca_dir, 'qilin-ca.crt')\n        ca_info_file = os.path.join(ca_dir, 'ca_info.json')\n        \n        print(f\"准备删除现有CA证书文件（如果存在）\")\n        for file in [ca_key, ca_crt, ca_info_file]:\n            try:\n                if os.path.exists(file):\n                    os.remove(file)\n                    print(f\"已删除文件: {file}\")\n            except Exception as file_error:\n                print(f\"删除文件失败: {file}, 错误: {str(file_error)}\")\n                return f\"删除现有CA证书文件失败: {str(file_error)}\", 500\n        \n        # 生成新的CA证书\n        print(\"开始生成新的CA证书...\")\n        try:\n            _, _, ca_info = generate_ca(org_name, password)\n            print(\"CA证书生成成功\")\n        except Exception as gen_error:\n            print(f\"生成CA证书失败: {str(gen_error)}\")\n            return f\"生成CA证书失败: {str(gen_error)}\", 500\n        \n        # 生成表格HTML\n        html = f'''\n        <tr>\n            <td>{ca_info['org_name']}</td>\n            <td>{ca_info['valid_until']}</td>\n            <td>{ca_info['created_at']}</td>\n            <td><a href=\"{url_for('download', cert_dir='ca', filename='qilin-ca.crt')}\"><i class=\"fas fa-download\"></i> 下载CA证书</a></td>\n        </tr>\n        '''\n        \n        return html\n    except Exception as e:\n        print(f\"创建CA证书时出现未捕获的错误: {str(e)}\")\n        return str(e), 500\n\n@app.route('/delete_ca', methods=['POST'])\ndef delete_ca():\n    try:\n        # 删除CA证书文件\n        ca_key = os.path.join(app.config['CA_DIR'], 'qilin-ca.key')\n        ca_crt = os.path.join(app.config['CA_DIR'], 'qilin-ca.crt')\n        ca_info_file = os.path.join(app.config['CA_DIR'], 'ca_info.json')\n        ca_srl = os.path.join(app.config['CA_DIR'], 'qilin-ca.srl')\n        \n        deleted_files = []\n        errors = []\n        \n        for file in [ca_key, ca_crt, ca_info_file, ca_srl]:\n            try:\n                if os.path.exists(file):\n                    os.remove(file)\n                    deleted_files.append(os.path.basename(file))\n            except Exception as file_error:\n                errors.append(f\"删除{os.path.basename(file)}失败: {str(file_error)}\")\n        \n        if errors:\n            print(f\"删除CA证书时出现错误: {', '.join(errors)}\")\n            return f\"删除文件时出现错误: {', '.join(errors)}\", 500\n        \n        if deleted_files:\n            print(f\"成功删除文件: {', '.join(deleted_files)}\")\n        else:\n            print(\"没有找到需要删除的文件\")\n        \n        # 返回空表格行\n        return '<tr class=\"empty-row\"><td colspan=\"4\">证书申请前需要创建虚拟机构，请点击左上角按钮创建</td></tr>'\n    except Exception as e:\n        print(f\"删除CA证书时出现未知错误: {str(e)}\")\n        return str(e), 500\n\n@app.route('/create_cert', methods=['POST'])\ndef create_cert():\n    # 获取用户输入\n    cert_name = request.form.get('cert_name', '')\n    ip_addresses = request.form.get('ip_addresses', '')\n    domains = request.form.get('domains', '')\n    password = request.form.get('cert_password', '')\n    \n    if not cert_name:\n        return \"证书名称不能为空\", 400\n    \n    # 检查CA证书是否存在\n    ca_key = os.path.join(app.config['CA_DIR'], 'qilin-ca.key')\n    ca_crt = os.path.join(app.config['CA_DIR'], 'qilin-ca.crt')\n    ca_info_file = os.path.join(app.config['CA_DIR'], 'ca_info.json')\n    \n    if not (os.path.exists(ca_key) and os.path.exists(ca_crt) and os.path.exists(ca_info_file)):\n        return \"请先创建虚拟机构，后申请证书\", 400\n    \n    try:\n        # 直接使用系统openssl命令\n        openssl_cmd = 'openssl'\n        print(f\"使用系统OpenSSL: {openssl_cmd}\")\n        config_param = []\n        \n        # 生成唯一目录\n        cert_dir = os.path.join(app.config['CERTS_DIR'], cert_name)\n        os.makedirs(cert_dir, exist_ok=True)\n\n        # 生成服务器证书文件名\n        key_file = os.path.join(cert_dir, f'{cert_name}.key')\n        csr_file = os.path.join(cert_dir, f'{cert_name}.csr')\n        crt_file = os.path.join(cert_dir, f'{cert_name}.crt')\n        ext_file = os.path.join(cert_dir, f'{cert_name}.ext')\n\n        # 生成私钥\n        key_cmd = [openssl_cmd, 'genrsa', '-out', key_file, '2048']\n        # 不再使用配置文件参数\n        subprocess.run(key_cmd, check=True)\n\n        # 生成 CSR\n        csr_cmd = [openssl_cmd, 'req', '-new', '-key', key_file,\n                  '-out', csr_file,\n                  '-config', '/etc/ssl/openssl.cnf',\n                  '-subj', f'/C=CN/ST=Guangdong/L=Shenzhen/O=qilin SSL CA/OU=IT Department/CN={cert_name}']\n        subprocess.run(csr_cmd, check=True)\n        # 构建SAN扩展内容\n        san_entries = []\n        \n        # 处理IP地址\n        if ip_addresses:\n            for ip in ip_addresses.split(';'):\n                ip = ip.strip()\n                if ip:\n                    san_entries.append(f'IP:{ip}')\n        \n        # 处理域名\n        if domains:\n            for domain in domains.split(';'):\n                domain = domain.strip()\n                if domain:\n                    san_entries.append(f'DNS:{domain}')\n        \n        # 如果没有指定任何SAN，至少添加证书名称作为DNS\n        if not san_entries:\n            san_entries.append(f'DNS:{cert_name}')\n        \n        san_string = ', '.join(san_entries)\n\n        # 创建扩展文件\n        with open(ext_file, 'w') as f:\n            f.write(f\"\"\"[req]\nreq_extensions = v3_req\n\n[v3_req]\nbasicConstraints = CA:FALSE\nkeyUsage = digitalSignature, keyEncipherment\nsubjectAltName = {san_string}\"\"\")\n\n        # 签发证书\n        ca_info_file = os.path.join(app.config['CA_DIR'], 'ca_info.json')\n        ca_key = os.path.join(app.config['CA_DIR'], 'qilin-ca.key')\n        ca_crt = os.path.join(app.config['CA_DIR'], 'qilin-ca.crt')\n        \n        # 读取CA信息以获取密码状态\n        if os.path.exists(ca_info_file):\n            with open(ca_info_file, 'r', encoding='utf-8') as f:\n                ca_info = json.load(f)\n                has_password = ca_info.get('has_password', False)\n        else:\n            has_password = False\n        \n        # 构建签名命令\n        sign_cmd = [\n            openssl_cmd, 'x509', '-req', '-in', csr_file,\n            '-CA', ca_crt, '-CAkey', ca_key,\n            '-CAcreateserial', '-out', crt_file,\n            '-days', '3650', '-extfile', ext_file, '-extensions', 'v3_req'\n        ]\n        \n        \n        # 如果CA密钥有密码保护，添加密码参数\n        if has_password and password:\n            sign_cmd.extend(['-passin', f'pass:{password}'])\n        elif has_password and not password:\n            return \"CA证书有密码保护，请提供密码\", 400\n        \n        # 执行签名命令，添加超时机制\n        try:\n            # 使用subprocess.Popen和communicate替代run，以便添加超时\n            process = subprocess.Popen(sign_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdout, stderr = process.communicate(timeout=10)  # 设置10秒超时\n            \n            # 检查命令执行结果\n            if process.returncode != 0:\n                error_msg = stderr.decode('utf-8', errors='ignore')\n                # 检查是否是密码错误\n                if \"bad decrypt\" in error_msg or \"bad password\" in error_msg:\n                    return \"CA证书密码错误，请重试\", 400\n                else:\n                    return f\"证书签发失败: {error_msg}\", 500\n        except subprocess.TimeoutExpired:\n            # 如果超时，终止进程并返回错误\n            process.kill()\n            return \"证书签发超时，可能是密码错误导致进程等待输入\", 500\n        \n        # 计算证书有效期\n        valid_until = (datetime.datetime.now() + datetime.timedelta(days=3650)).strftime('%Y-%m-%d')\n    \n        # 处理IP地址显示，转换为HTML列表格式\n        if ip_addresses:\n            ip_list = ip_addresses.split('\\n')\n            has_more_ip = len(ip_list) > 3\n            ip_html = '<ul class=\"address-list' + (' has-more' if has_more_ip else '') + '\">' \n            for ip in ip_list:  # 显示所有IP地址\n                ip_html += f'<li>{ip}</li>'\n            ip_html += '</ul>'\n            display_ip = ip_html\n        else:\n            display_ip = '/'\n        \n        # 处理域名显示，转换为HTML列表格式\n        if domains:\n            domain_list = domains.split('\\n')\n            has_more_domain = len(domain_list) > 3\n            domain_html = '<ul class=\"address-list' + (' has-more' if has_more_domain else '') + '\">' \n            for domain in domain_list:  # 显示所有域名\n                domain_html += f'<li>{domain}</li>'\n            domain_html += '</ul>'\n            display_domains = domain_html\n        else:\n            display_domains = '/'\n        \n        # 生成表格HTML\n        html = f'''\n    <tr>\n        <td><input type=\"checkbox\" class=\"cert-checkbox\" data-cert-name=\"{cert_name}\"></td>\n        <td>{cert_name}</td>\n        <td>{valid_until}</td>\n        <td title=\"{ip_addresses.replace('/', ', ') if ip_addresses else '/'}\" class=\"ip-address\">{display_ip}</td>\n        <td title=\"{domains.replace('/', ', ') if domains else '/'}\" class=\"domain-name\">{display_domains}</td>\n        <td><a href=\"{url_for('download', cert_dir=cert_dir, filename=f'{cert_name}.crt')}\"><i class=\"fas fa-certificate\"></i> {cert_name}.crt</a></td>\n        <td><a href=\"{url_for('download', cert_dir=cert_dir, filename=f'{cert_name}.key')}\"><i class=\"fas fa-key\"></i> {cert_name}.key</a></td>\n    </tr>\n    '''\n        \n        return html\n    except Exception as e:\n        return str(e), 500\n\n@app.route('/download/<path:cert_dir>/<filename>')\ndef download(cert_dir, filename):\n    # 检查cert_dir是否是相对路径，如果是，则拼接CERTS_DIR\n    if not os.path.isabs(cert_dir):\n        if cert_dir == 'ca':\n            # 如果是CA证书目录\n            full_path = os.path.join(app.config['CA_DIR'], filename)\n        else:\n            # 如果是普通证书目录\n            full_path = os.path.join(app.config['CERTS_DIR'], cert_dir, filename)\n    else:\n        full_path = os.path.join(cert_dir, filename)\n    \n    # 检查文件是否存在\n    if not os.path.exists(full_path):\n        return f\"文件不存在: {full_path}\", 404\n        \n    return send_file(full_path, as_attachment=True)\n\n@app.route('/start_https_server/<path:cert_dir>')\ndef start_https_server(cert_dir):\n    # 获取证书和私钥路径\n    server_crt = os.path.join(cert_dir, 'server.crt')\n    server_key = os.path.join(cert_dir, 'server.key')\n    \n    # 设置全局变量，用于在主程序中启动HTTPS服务器\n    app.config['HTTPS_SERVER_ENABLED'] = True\n    app.config['HTTPS_SERVER_CERT'] = server_crt\n    app.config['HTTPS_SERVER_KEY'] = server_key\n    \n    return redirect(url_for('index', https_started=True))\n\n@app.route('/https_test')\ndef https_test():\n    return \"<h1>HTTPS服务器测试成功！</h1><p>您已成功使用生成的SSL证书建立了安全连接。</p>\"\n\n@app.route('/verify_cert', methods=['POST'])\ndef verify_cert():\n    \"\"\"验证证书按钮的路由处理函数\"\"\"\n    try:\n        # 获取用户输入的IP地址或域名\n        address = request.form.get('address', '')\n        cert_type = request.form.get('cert_type', 'qilin')\n        \n        if not address:\n            return jsonify({'success': False, 'message': '请输入IP地址或域名'}), 400\n        \n        # 确定证书和私钥文件路径\n        if cert_type == 'qilin':\n            # 使用qilin SSL申请的证书\n            cert_name = request.form.get('cert_name', '')\n            if not cert_name:\n                return jsonify({'success': False, 'message': '请选择证书'}), 400\n                \n            cert_dir = os.path.join(app.config['CERTS_DIR'], cert_name)\n            cert_file = os.path.join(cert_dir, f'{cert_name}.crt')\n            key_file = os.path.join(cert_dir, f'{cert_name}.key')\n            \n            if not (os.path.exists(cert_file) and os.path.exists(key_file)):\n                return jsonify({'success': False, 'message': '证书文件不存在'}), 404\n        else:\n            # 使用上传的自定义证书\n            cert_filename = request.form.get('cert_filename', '')\n            key_filename = request.form.get('key_filename', '')\n            \n            if not cert_filename or not key_filename:\n                return jsonify({'success': False, 'message': '请上传证书和私钥文件'}), 400\n                \n            cert_file = os.path.join(app.config['UPLOAD_DIR'], cert_filename)\n            key_file = os.path.join(app.config['UPLOAD_DIR'], key_filename)\n            \n            if not (os.path.exists(cert_file) and os.path.exists(key_file)):\n                return jsonify({'success': False, 'message': '上传的证书文件不存在'}), 404\n        \n        # 使用Python的http.server和ssl模块创建HTTPS服务器\n        import http.server\n        import socketserver\n        import threading\n        import socket\n        \n        # 定义一个简单的HTTP请求处理器\n        class SSLVerifyHandler(http.server.SimpleHTTPRequestHandler):\n            def do_GET(self):\n                self.send_response(200)\n                self.send_header('Content-Type', 'text/html; charset=utf-8')\n                self.end_headers()\n                html_content = f'''\n                <!DOCTYPE html>\n                <html lang=\"zh-CN\">\n                <head>\n                    <meta charset=\"UTF-8\">\n                    <title>SSL证书验证</title>\n                    <style>\n                        body {{font-family: Arial, sans-serif; margin: 40px; line-height: 1.6;}}\n                        h1 {{color: #4CAF50;}}\n                        p {{font-size: 16px;}}\n                        #countdown {{font-size: 24px; color: #ff6b6b; font-weight: bold;}}\n                    </style>\n                    <script>\n                        window.onload = function() {{\n                            var timeLeft = 30;\n                            var countdownElement = document.getElementById('countdown');\n                            \n                            function updateCountdown() {{\n                                countdownElement.textContent = timeLeft;\n                                if (timeLeft > 0) {{\n                                    timeLeft--;\n                                    setTimeout(updateCountdown, 1000);\n                                }} else {{\n                                    window.close();\n                                }}\n                            }}\n                            \n                            updateCountdown();\n                        }}\n                    </script>\n                </head>\n                <body>\n                    <h1>SSL证书验证页面</h1>\n                    <p>请检查网址前方是否有不安全提醒，如果没有即通过验证。</p>\n                    <p>此页面将在 <span id=\"countdown\">30</span> 秒后自动关闭。</p>\n                </body>\n                </html>\n                '''\n                self.wfile.write(html_content.encode('utf-8'))\n            \n            def log_message(self, format, *args):\n                # 重写日志方法，避免在控制台输出过多信息\n                pass\n        \n        # 创建一个临时目录存放证书和私钥\n        temp_ssl_dir = os.path.join(os.path.abspath('temp_ssl'))\n        os.makedirs(temp_ssl_dir, exist_ok=True)\n        \n        # 复制证书和私钥到临时目录\n        temp_cert = os.path.join(temp_ssl_dir, 'server.crt')\n        temp_key = os.path.join(temp_ssl_dir, 'server.key')\n        \n        shutil.copy2(cert_file, temp_cert)\n        shutil.copy2(key_file, temp_key)\n        \n        # 创建HTTPS服务器\n        print(\"开始创建Python HTTPS服务器...\")\n        \n        # 定义全局变量存储服务器实例和线程\n        global https_server\n        global https_thread\n        \n        # 设置服务器端口\n        server_port = 16888\n        \n        # 创建SSL上下文\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        context.load_cert_chain(temp_cert, temp_key)\n        \n        # 创建HTTP服务器\n        httpd = http.server.HTTPServer(('0.0.0.0', server_port), SSLVerifyHandler)\n        \n        # 将服务器包装为HTTPS服务器\n        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)\n        \n        # 保存服务器实例到全局变量\n        https_server = httpd\n        \n        # 定义服务器运行函数\n        def run_server():\n            try:\n                print(f\"HTTPS服务器正在监听端口 {server_port}...\")\n                https_server.serve_forever()\n            except Exception as e:\n                print(f\"HTTPS服务器运行出错: {str(e)}\")\n        \n        # 在新线程中启动服务器\n        https_thread = threading.Thread(target=run_server)\n        https_thread.daemon = True\n        https_thread.start()\n        \n        # 检查服务器是否成功启动\n        verify_url = f\"https://{address}:{server_port}\"\n        time.sleep(1)  # 等待一秒，让服务器有时间启动\n        try:\n            # 尝试连接到服务器\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(1)\n            try:\n                s.connect((address, server_port))\n                print(\"成功连接到HTTPS服务器\")\n                # 使用webbrowser模块自动打开验证URL\n                import webbrowser\n                webbrowser.open(verify_url)\n            except Exception as e:\n                print(f\"连接到HTTPS服务器失败: {str(e)}\")\n            finally:\n                s.close()\n        except Exception as e:\n            print(f\"检查HTTPS服务器状态时出错: {str(e)}\")\n        # 设置30秒后自动关闭HTTPS服务器\n        def stop_https_server():\n            try:\n                if https_server:\n                    print(\"正在关闭HTTPS服务器...\")\n                    https_server.shutdown()\n                    print(\"HTTPS服务器已停止\")\n                    \n                    # 清理临时文件\n                    try:\n                        if os.path.exists(temp_cert):\n                            os.remove(temp_cert)\n                        if os.path.exists(temp_key):\n                            os.remove(temp_key)\n                    except Exception as e:\n                        print(f\"清理临时文件完成\")\n            except Exception as e:\n                print(f\"停止HTTPS服务器时出错: {str(e)}\")\n        \n        # 创建定时器\n        timer = threading.Timer(30, stop_https_server)\n        timer.daemon = True  # 设置为守护线程，这样如果主程序退出，定时器也会退出\n        timer.start()\n        print(f\"已设置30秒后自动关闭HTTPS服务器的定时器\")\n        \n        # 返回成功信息和验证URL\n        \n        print(f\"验证URL: {verify_url}\")\n        return jsonify({\n            'success': True, \n            'message': '验证服务器已启动，30秒后将自动关闭',\n            'verify_url': verify_url\n        })\n        \n    except Exception as e:\n        import traceback\n        error_trace = traceback.format_exc()\n        print(f\"启动验证服务器时出错: {str(e)}\")\n        print(f\"错误详情:\\n{error_trace}\")\n        \n        # 清理可能创建的临时文件\n        try:\n            if 'temp_cert' in locals() and os.path.exists(temp_cert):\n                os.remove(temp_cert)\n            if 'temp_key' in locals() and os.path.exists(temp_key):\n                os.remove(temp_key)\n        except Exception as cleanup_error:\n            print(f\"清理临时文件时出错: {str(cleanup_error)}\")\n        \n        return jsonify({'success': False, 'message': f'启动验证服务器失败: {str(e)}'}), 500\n\n\n@app.route('/check_ca_password')\ndef check_ca_password():\n    \"\"\"检查CA证书是否有密码保护\"\"\"\n    ca_info_file = os.path.join(app.config['CA_DIR'], 'ca_info.json')\n    \n    if os.path.exists(ca_info_file):\n        with open(ca_info_file, 'r', encoding='utf-8') as f:\n            ca_info = json.load(f)\n            has_password = ca_info.get('has_password', False)\n            return jsonify({'has_password': has_password})\n    \n    return jsonify({'has_password': False})\n\n@app.route('/list_certs')\ndef list_certs():\n    \"\"\"扫描certs目录，根据请求类型返回HTML表格行或JSON格式的证书列表\"\"\"\n    try:\n        # 检查请求是否期望JSON响应\n        want_json = request.headers.get('Accept', '').find('application/json') != -1\n        page = request.args.get('page', 1, type=int)\n        per_page = 8\n        certs_dir = app.config['CERTS_DIR']\n        html_rows = []\n        cert_list = []\n        \n        # 检查certs目录是否存在\n        if not os.path.exists(certs_dir):\n            return ''\n        \n        # 遍历certs目录下的所有子目录\n        for cert_name in os.listdir(certs_dir):\n            cert_dir = os.path.join(certs_dir, cert_name)\n            \n            # 只处理目录，并排除CA证书目录\n            if not os.path.isdir(cert_dir) or cert_name == 'ca':\n                continue\n            \n            # 检查是否存在证书和私钥文件\n            crt_file = os.path.join(cert_dir, f'{cert_name}.crt')\n            key_file = os.path.join(cert_dir, f'{cert_name}.key')\n            ext_file = os.path.join(cert_dir, f'{cert_name}.ext')\n            \n            if not (os.path.exists(crt_file) and os.path.exists(key_file)):\n                continue\n            \n            # 从扩展文件中提取IP和域名信息\n            ip_addresses = ''\n            domains = ''\n            \n            if os.path.exists(ext_file):\n                with open(ext_file, 'r') as f:\n                    ext_content = f.read()\n                    # 查找subjectAltName行\n                    for line in ext_content.split('\\n'):\n                        if 'subjectAltName' in line:\n                            # 提取SAN值\n                            san_parts = line.split('=')[1].strip().split(', ')\n                            ip_list = []\n                            domain_list = []\n                            \n                            for part in san_parts:\n                                if part.startswith('IP:'):\n                                    ip_list.append(part[3:])\n                                elif part.startswith('DNS:'):\n                                    domain_list.append(part[4:])\n                            \n                            ip_addresses = '\\n'.join(ip_list)\n                            domains = '\\n'.join(domain_list)\n                            break\n            \n            # 计算证书有效期（这里简化处理，使用当前日期加一年）\n            valid_until = (datetime.datetime.now() + datetime.timedelta(days=3650)).strftime('%Y-%m-%d')\n            \n            # 处理IP地址显示，转换为HTML列表格式\n            if ip_addresses:\n                ip_list = ip_addresses.split('\\n')\n                has_more_ip = len(ip_list) > 3\n                ip_html = '<ul class=\"address-list' + (' has-more' if has_more_ip else '') + '\">' \n                for ip in ip_list:  # 显示所有IP地址\n                    ip_html += f'<li>{ip}</li>'\n                ip_html += '</ul>'\n                display_ip = ip_html\n            else:\n                display_ip = '/'\n            \n            # 处理域名显示，转换为HTML列表格式\n            if domains:\n                domain_list = domains.split('\\n')\n                has_more_domain = len(domain_list) > 3\n                domain_html = '<ul class=\"address-list' + (' has-more' if has_more_domain else '') + '\">' \n                for domain in domain_list:  # 显示所有域名\n                    domain_html += f'<li>{domain}</li>'\n                domain_html += '</ul>'\n                display_domains = domain_html\n            else:\n                display_domains = '/'\n            \n            # 生成表格行HTML\n            html = f'''\n    <tr>\n        <td><input type=\"checkbox\" class=\"cert-checkbox\" data-cert-name=\"{cert_name}\"></td>\n        <td>{cert_name}</td>\n        <td>{valid_until}</td>\n        <td title=\"{ip_addresses.replace('/', ', ') if ip_addresses else '/'}\" class=\"ip-address\">{display_ip}</td>\n        <td title=\"{domains.replace('/', ', ') if domains else '/'}\" class=\"domain-name\">{display_domains}</td>\n        <td><a href=\"{url_for('download', cert_dir=cert_name, filename=f'{cert_name}.crt')}\"><i class=\"fas fa-certificate\"></i> {cert_name}.crt</a></td>\n        <td><a href=\"{url_for('download', cert_dir=cert_name, filename=f'{cert_name}.key')}\"><i class=\"fas fa-key\"></i> {cert_name}.key</a></td>\n    </tr>\n    '''\n            \n            # 添加证书信息到JSON列表\n            cert_info = {\n                'name': cert_name,\n                'valid_until': valid_until,\n                'ip_addresses': ip_addresses.split('\\n') if ip_addresses else [],\n                'domains': domains.split('\\n') if domains else [],\n                'files': {\n                    'crt': f'{cert_name}.crt',\n                    'key': f'{cert_name}.key'\n                }\n            }\n            cert_list.append(cert_info)\n            html_rows.append(html)\n        \n        if want_json:\n            return jsonify({'certs': cert_list})\n        \n        if html_rows:\n            # 计算总页数\n            total_pages = (len(html_rows) + per_page - 1) // per_page\n            # 获取当前页的数据\n            start_idx = (page - 1) * per_page\n            end_idx = start_idx + per_page\n            current_page_rows = html_rows[start_idx:end_idx]\n            \n            # 只在总页数大于1时才显示分页HTML\n            pagination_html = ''\n            if total_pages > 1:\n                pagination_html = '<tr class=\"pagination-row\"><td colspan=\"7\"><div class=\"pagination\">'\n                if page > 1:\n                    pagination_html += f'<a href=\"#\" class=\"page-link\" data-page=\"{page-1}\">上一页</a>'\n                for p in range(1, total_pages + 1):\n                    if p == page:\n                        pagination_html += f'<span class=\"page-link active\">{p}</span>'\n                    else:\n                        pagination_html += f'<a href=\"#\" class=\"page-link\" data-page=\"{p}\">{p}</a>'\n                if page < total_pages:\n                    pagination_html += f'<a href=\"#\" class=\"page-link\" data-page=\"{page+1}\">下一页</a>'\n                pagination_html += '</div></td></tr>'\n            \n            return ''.join(current_page_rows) + pagination_html\n        else:\n            return '<tr class=\"empty-row\"><td colspan=\"7\">创建虚拟机构后，再点击新增按钮申请证书</td></tr>'\n    except Exception as e:\n        print(f\"获取证书列表时出错: {str(e)}\")\n        return '<tr class=\"empty-row\"><td colspan=\"7\">获取证书列表时出错</td></tr>'\n\n@app.route('/delete_certs', methods=['POST'])\ndef delete_certs():\n    \"\"\"删除选中的证书\"\"\"\n    try:\n        # 获取要删除的证书名称列表\n        cert_names = request.json.get('cert_names', [])\n        print(f\"收到删除证书请求，证书列表: {cert_names}\")\n        # 确保cert_names是字符串列表\n        cert_names = [str(name) for name in cert_names if name]\n        if not cert_names:\n            print(\"未选择任何证书，返回错误\")\n            return jsonify({\n                'status': 'error',\n                'message': '请选择要删除的证书',\n                'html': '<tr class=\"empty-row\"><td colspan=\"7\">请选择要删除的证书</td></tr>'\n            }), 400\n\n        errors = []\n        success_count = 0\n\n        # 删除每个选中的证书\n        for cert_name in cert_names:\n            # 对证书名称进行编码\n            encoded_cert_name = quote(cert_name)\n            cert_dir = os.path.normpath(os.path.join(app.config['CERTS_DIR'], encoded_cert_name))\n            \n            if not os.path.exists(cert_dir):\n                errors.append(f'证书 {cert_name} 目录不存在')\n                continue\n                \n            if not os.path.isdir(cert_dir):\n                errors.append(f'路径 {cert_name} 不是目录')\n                continue\n            \n            try:\n                print(f\"开始处理证书: {cert_name}, 目录路径: {cert_dir}\")\n                # 删除证书相关文件\n                for file_name in [f'{cert_name}.crt', f'{cert_name}.key', f'{cert_name}.csr', f'{cert_name}.ext']:\n                    # 对文件名进行编码\n                    encoded_file_name = quote(file_name)\n                    file_path = os.path.normpath(os.path.join(cert_dir, encoded_file_name))\n                    \n                    try:\n                        if os.path.exists(file_path):\n                            \n                            # 尝试打开文件以检查是否被占用\n                            try:\n                                with open(file_path, 'a'):\n                                    pass                               \n                            except IOError:\n                                print(f\"文件被占用，无法删除: {file_path}\")\n                                errors.append(f'文件 {file_name} 正在被其他程序使用，无法删除')\n                                continue\n                            os.remove(file_path)\n                        else:\n                            print(f\"文件不存在，跳过: {file_path}\")\n                    except (PermissionError, OSError) as e:\n                        print(f\"删除文件失败: {file_path}, 错误: {str(e)}\")\n                        errors.append(f'删除文件 {file_name} 失败: {str(e)}')\n                        continue\n\n                # 检查目录是否为空\n                remaining_files = os.listdir(cert_dir)\n                if remaining_files:\n                    print(f\"目录不为空，剩余文件: {remaining_files}\")\n                    errors.append(f'目录 {cert_name} 不为空，可能有文件正在被占用')\n                    continue\n                else:\n                    print(f\"目录为空，可以安全删除: {cert_dir}\")\n\n                # 删除证书目录\n                try:\n                    print(f\"准备删除证书目录: {cert_dir}\")\n                    # 检查目录是否存在\n                    if os.path.exists(cert_dir):\n                        # 尝试修改文件权限\n                        def on_rm_error(func, path, exc_info):\n                            print(f\"删除时遇到权限错误: {path}\")\n                            # 尝试修改文件权限\n                            os.chmod(path, stat.S_IWRITE)\n                            # 再次尝试删除\n                            func(path)\n                        \n                        # 使用shutil.rmtree强制删除目录及其内容\n                        print(f\"使用shutil.rmtree删除目录: {cert_dir}\")\n                        shutil.rmtree(cert_dir, onerror=on_rm_error)\n                        print(f\"成功删除证书目录: {cert_dir}\")\n                        success_count += 1\n                    else:\n                        print(f\"证书目录不存在: {cert_dir}\")\n                        errors.append(f'证书目录不存在: {cert_dir}')\n                except (PermissionError, OSError) as e:\n                    print(f\"删除目录失败: {cert_dir}, 错误: {str(e)}\")\n                    errors.append(f'删除目录 {cert_name} 失败: {str(e)}')\n                    print(f\"请检查文件权限或是否被其他程序占用\")\n                    # 不再尝试使用系统命令强制删除\n\n            except Exception as e:\n                errors.append(f'处理证书 {cert_name} 时出错: {str(e)}')\n\n        # 准备响应信息\n        if success_count > 0:\n            # 成功删除至少一个证书，直接返回成功状态\n            return jsonify({\n                'status': 'success'\n            })\n        else:\n            # 全部失败\n            return jsonify({\n                'status': 'error',\n                'message': '删除证书失败'\n            }), 500\n\n    except Exception as e:\n        return jsonify({\n            'status': 'error',\n            'message': f'删除证书时出错: {str(e)}',\n            'html': '<tr class=\"empty-row\"><td colspan=\"7\">删除证书时出错，请稍后重试</td></tr>'\n        }), 500\n\n# 初始化代理数据文件\ndef init_proxy_data_file():\n    proxy_data_file = app.config.get('PROXY_DATA_FILE')\n    if not proxy_data_file:\n        app.config['PROXY_DATA_FILE'] = 'proxy/proxy_data.json'\n        proxy_data_file = app.config['PROXY_DATA_FILE']\n    \n    if not os.path.exists(proxy_data_file):\n        with open(proxy_data_file, 'w', encoding='utf-8') as f:\n            json.dump([], f)\n    return proxy_data_file\n\n# 确保代理数据文件存在\ninit_proxy_data_file()\n\n@app.route('/get_proxy_list', methods=['GET'])\ndef get_proxy_list():\n    try:\n        # 获取代理数据文件路径\n        proxy_data_file = app.config.get('PROXY_DATA_FILE')\n        if not os.path.exists(proxy_data_file):\n            # 如果文件不存在，初始化一个空列表\n            return jsonify({\n                'success': True,\n                'proxies': []\n            })\n        \n        # 读取代理数据\n        with open(proxy_data_file, 'r', encoding='utf-8') as f:\n            proxy_data = json.load(f)\n        \n        return jsonify({\n            'success': True,\n            'proxies': proxy_data\n        })\n    except Exception as e:\n        print(f\"获取代理列表时出错: {str(e)}\")\n        return jsonify({\n            'success': False,\n            'message': f'获取代理列表时出错: {str(e)}',\n            'proxies': []\n        }), 500\n\n@app.route('/delete_proxy', methods=['POST'])\ndef delete_proxy():\n    try:\n        # 获取要删除的代理ID列表\n        proxy_ids = request.json.get('proxy_ids', [])\n        if not proxy_ids:\n            return jsonify({\n                'success': False,\n                'message': '请选择要删除的代理服务'\n            }), 400\n\n        # 获取代理数据文件路径\n        proxy_data_file = os.path.join('proxy', 'proxy_data.json')\n        if not os.path.exists(proxy_data_file):\n            return jsonify({\n                'success': False,\n                'message': '代理数据文件不存在'\n            }), 404\n\n        # 读取现有数据\n        with open(proxy_data_file, 'r', encoding='utf-8') as f:\n            proxies = json.load(f)\n\n        # 记录删除的代理和未找到的代理\n        deleted_proxies = []\n        not_found_proxies = []\n\n        # 过滤出要保留的代理和要删除的代理\n        new_proxies = []\n        # 确保proxy_ids中的所有ID都是字符串类型\n        proxy_ids = [str(pid) for pid in proxy_ids]\n        for proxy in proxies:\n            if str(proxy.get('id')) in proxy_ids:\n                # 尝试停止服务\n                proxy_id = str(proxy.get('id'))\n                toml_path = f\"./toml/{proxy_id}.toml\"\n                cmd = f'kill $(pgrep -f \"rhttp -c {toml_path}\")'\n                \n                try:\n                    # 执行命令获取进程ID\n                    result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n                    if result.stderr:\n                        print(f\"获取进程ID失败: {result.stderr}\")\n                except Exception as e:\n                    print(f\"获取进程ID失败: {str(e)}\")\n                \n                deleted_proxies.append(proxy)\n            else:\n                new_proxies.append(proxy)\n\n        # 检查是否有未找到的代理\n        not_found_proxies = [proxy_id for proxy_id in proxy_ids if proxy_id not in [p.get('id') for p in deleted_proxies]]\n\n        # 保存更新后的数据\n        with open(proxy_data_file, 'w', encoding='utf-8') as f:\n            json.dump(new_proxies, f, ensure_ascii=False, indent=2)\n\n        # 返回删除结果\n        return jsonify({\n            'success': True,\n            'deleted': [p.get('id') for p in deleted_proxies],\n            'not_found': not_found_proxies,\n            'message': '代理服务删除成功'\n        })\n\n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'message': f'删除代理服务失败：{str(e)}'\n        }), 500\n\n@app.route('/create_proxy', methods=['POST'])\ndef create_proxy():\n    try:\n        # 获取表单数据\n        service_name = request.form.get('service_name')\n        original_url = request.form.get('original_url')\n        proxy_url = request.form.get('proxy_url')\n        cert_type = request.form.get('cert_type')\n\n        # 验证必填字段\n        if not all([service_name, original_url, proxy_url]):\n            return jsonify({\n                'success': False,\n                'message': '请填写所有必填字段'\n            }), 400\n\n        # 根据证书类型获取证书文件\n        cert_filename = None\n        key_filename = None\n        cert_id = None\n        \n        if cert_type == 'qilin':\n            cert_id = request.form.get('cert_id')\n            if not cert_id:\n                return jsonify({\n                    'success': False,\n                    'message': '请选择证书'\n                }), 400\n\n            # 获取qilin ssl证书文件路径\n            cert_dir = os.path.join(app.config['CERTS_DIR'], cert_id)\n            cert_file = os.path.join(cert_dir, f'{cert_id}.crt')\n            key_file = os.path.join(cert_dir, f'{cert_id}.key')\n\n            if not (os.path.exists(cert_file) and os.path.exists(key_file)):\n                return jsonify({\n                    'success': False,\n                    'message': '证书文件不存在'\n                }), 404\n        else:\n            # 处理自定义证书\n            cert_filename = request.form.get('cert_filename')\n            key_filename = request.form.get('key_filename')\n            \n            # 处理上传的文件\n            cert_file = request.files.get('cert_file')\n            key_file = request.files.get('key_file')\n            \n            # 如果没有提供现有证书文件名且没有上传任何文件\n            if (not cert_filename and not cert_file) or (not key_filename and not key_file):\n                return jsonify({\n                    'success': False,\n                    'message': '请提供证书和私钥文件'\n                }), 400\n                \n            # 处理证书文件\n            if cert_file:\n                if cert_file.filename == '':\n                    return jsonify({\n                        'success': False,\n                        'message': '请选择有效的证书文件'\n                    }), 400\n                cert_filename = secure_filename(cert_file.filename)\n                cert_file_path = os.path.join(app.config['UPLOAD_DIR'], cert_filename)\n                cert_file.save(cert_file_path)\n            \n            # 处理私钥文件\n            if key_file:\n                if key_file.filename == '':\n                    return jsonify({\n                        'success': False,\n                        'message': '请选择有效的私钥文件'\n                    }), 400\n                key_filename = secure_filename(key_file.filename)\n                key_file_path = os.path.join(app.config['UPLOAD_DIR'], key_filename)\n                key_file.save(key_file_path)\n            else:\n                # 验证现有证书文件是否存在\n                cert_file_path = os.path.join(app.config['UPLOAD_DIR'], cert_filename)\n                key_file_path = os.path.join(app.config['UPLOAD_DIR'], key_filename)\n                if not (os.path.exists(cert_file_path) and os.path.exists(key_file_path)):\n                    return jsonify({\n                        'success': False,\n                        'message': '证书文件不存在'\n                    }), 404\n\n\n        # 获取证书有效期\n        if cert_type == 'qilin':\n            # 从证书列表中获取有效期\n            cert_list_file = os.path.join(app.config['CERTS_DIR'], cert_id, f'{cert_id}.crt')\n            try:\n                # 使用本地OpenSSL命令获取证书有效期\n                openssl_path = 'openssl'\n                cmd = [openssl_path, 'x509', '-in', cert_list_file, '-enddate', '-noout']\n                result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n                if result.stderr:\n                    print(f\"OpenSSL命令警告: {result.stderr}\")\n                # 解析输出格式：notAfter=Dec 31 23:59:59 2024 GMT\n                expiry_str = result.stdout.strip().split('=')[1]\n                expiry_date = datetime.datetime.strptime(expiry_str, '%b %d %H:%M:%S %Y GMT')\n                cert_expiry = expiry_date.strftime('%Y-%m-%d')\n            except Exception as e:\n                print(f\"获取证书有效期失败: {str(e)}\")\n                cert_expiry = (datetime.datetime.now() + datetime.timedelta(days=3650)).strftime('%Y-%m-%d')\n        else:\n            # 读取上传的证书文件获取有效期\n            try:\n                openssl_path = 'openssl'\n                cmd = [openssl_path, 'x509', '-in', cert_file_path, '-enddate', '-noout']\n                result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n                if result.stderr:\n                    print(f\"OpenSSL命令警告: {result.stderr}\")\n                # 解析输出格式：notAfter=Dec 31 23:59:59 2024 GMT\n                expiry_str = result.stdout.strip().split('=')[1]\n                expiry_date = datetime.datetime.strptime(expiry_str, '%b %d %H:%M:%S %Y GMT')\n                cert_expiry = expiry_date.strftime('%Y-%m-%d')\n            except Exception as e:\n                print(f\"获取证书有效期失败: {str(e)}\")\n                cert_expiry = (datetime.datetime.now() + datetime.timedelta(days=3650)).strftime('%Y-%m-%d')\n        \n        # 创建代理数据\n        proxy_data = {\n            'id': service_name,\n            'service_name': service_name,\n            'original_url': original_url,\n            'proxy_url': proxy_url,\n            'cert_type': cert_type,\n            'cert_id': cert_id,\n            'cert_filename': cert_filename,\n            'key_filename': key_filename,\n            'cert_expiry': cert_expiry,\n            'created_at': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        }\n        \n        # 保存到代理数据文件\n        proxy_data_file = app.config.get('PROXY_DATA_FILE')\n        if not os.path.exists(proxy_data_file):\n            # 如果文件不存在，创建一个空列表\n            proxies = []\n        else:\n            # 读取现有数据\n            with open(proxy_data_file, 'r', encoding='utf-8') as f:\n                proxies = json.load(f)\n        \n        # 检查是否已存在同名代理\n        for i, proxy in enumerate(proxies):\n            if proxy.get('id') == service_name:\n                # 如果存在同名代理，更新它\n                proxies[i] = proxy_data\n                break\n        else:\n            # 如果不存在同名代理，添加新代理\n            proxies.append(proxy_data)\n        \n        # 保存更新后的数据\n        with open(proxy_data_file, 'w', encoding='utf-8') as f:\n            json.dump(proxies, f, ensure_ascii=False, indent=2)\n\n        return jsonify({\n            'success': True,\n            'proxy_id': service_name,\n            'cert_expiry': cert_expiry,\n            'message': '反向代理创建成功'\n        })\n\n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'message': f'创建反向代理失败：{str(e)}'\n        }), 500\n\n@app.route('/run_proxy', methods=['POST'])\ndef run_proxy():\n    try:\n        print(\"开始处理run_proxy请求...\")\n        # 获取要运行的代理ID\n        proxy_id = request.json.get('proxy_id')\n        print(f\"接收到的proxy_id: {proxy_id}\")\n        if not proxy_id:\n            print(\"错误：未提供proxy_id\")\n            return jsonify({\n                'success': False,\n                'message': '请选择要运行的代理服务'\n            }), 400\n\n        # 获取代理数据文件路径\n        proxy_data_file = app.config.get('PROXY_DATA_FILE')\n        print(f\"代理数据文件路径: {proxy_data_file}\")\n        if not os.path.exists(proxy_data_file):\n            print(f\"错误：代理数据文件不存在: {proxy_data_file}\")\n            return jsonify({\n                'success': False,\n                'message': '代理数据文件不存在'\n            }), 404\n\n        # 读取代理数据\n        print(\"开始读取代理数据文件...\")\n        with open(proxy_data_file, 'r', encoding='utf-8') as f:\n            proxies = json.load(f)\n        print(f\"成功读取代理数据，共有{len(proxies)}条记录\")\n\n        # 查找指定的代理\n        proxy_data = None\n        # 确保proxy_id是字符串类型\n        proxy_id = str(proxy_id)\n        for proxy in proxies:\n            # 将proxy中的id也转换为字符串进行比较\n            if str(proxy.get('id')) == proxy_id:\n                proxy_data = proxy\n                print(f\"找到匹配的代理数据: {json.dumps(proxy, ensure_ascii=False)}\")\n                break\n\n        if not proxy_data:\n            print(f\"错误：未找到ID为{proxy_id}的代理服务\")\n            return jsonify({\n                'success': False,\n                'message': f'未找到ID为{proxy_id}的代理服务'\n            }), 404\n\n        # 设置反向代理工作目录\n        proxy_dir = os.path.join(app.config['BASE_DIR'], 'proxy')\n        toml_dir = os.path.join(proxy_dir, 'toml')\n        cert_dir = os.path.join(proxy_dir, 'cert')\n\n        # 确保目录存在\n        os.makedirs(toml_dir, exist_ok=True)\n        os.makedirs(cert_dir, exist_ok=True)\n\n        # 准备证书文件\n        cert_path = None\n        key_path = None\n\n        if proxy_data.get('cert_type') == 'qilin':\n            print(\"处理qilin类型证书...\")\n            # 使用qilin证书\n            cert_id = proxy_data.get('cert_id')\n            print(f\"获取到的cert_id: {cert_id}\")\n            if not cert_id:\n                print(\"错误：证书ID不存在\")\n                return jsonify({\n                    'success': False,\n                    'message': '证书ID不存在'\n                }), 400\n\n            # 源证书路径\n            src_cert = os.path.join(app.config['CERTS_DIR'], cert_id, f'{cert_id}.crt')\n            src_key = os.path.join(app.config['CERTS_DIR'], cert_id, f'{cert_id}.key')\n\n            # 检查源证书文件是否存在\n            if not os.path.exists(src_cert) or not os.path.exists(src_key):\n                print(f\"错误：证书文件不存在，cert存在: {os.path.exists(src_cert)}, key存在: {os.path.exists(src_key)}\")\n                return jsonify({\n                    'success': False,\n                    'message': '证书文件不存在'\n                }), 404\n            # 目标证书路径\n            cert_path = os.path.join(cert_dir, f'{proxy_id}.crt')\n            key_path = os.path.join(cert_dir, f'{proxy_id}.key')\n            print(f\"目标证书路径: {cert_path}\")\n            print(f\"目标私钥路径: {key_path}\")\n\n            # 复制证书文件\n            try:\n                # 如果目标文件已存在，先删除\n                if os.path.exists(cert_path):\n                    os.remove(cert_path)\n                if os.path.exists(key_path):\n                    os.remove(key_path)\n                    \n                shutil.copy2(src_cert, cert_path)\n                print(f\"成功复制证书文件: {src_cert} -> {cert_path}\")\n                shutil.copy2(src_key, key_path)\n                print(f\"成功复制私钥文件: {src_key} -> {key_path}\")\n            except Exception as e:\n                print(f\"复制证书文件时出错: {str(e)}\")\n                return jsonify({\n                    'success': False,\n                    'message': f'复制证书文件失败: {str(e)}'\n                }), 500\n        else:\n            # 使用自定义证书\n            cert_filename = proxy_data.get('cert_filename')\n            key_filename = proxy_data.get('key_filename')\n\n            if not cert_filename or not key_filename:\n                return jsonify({\n                    'success': False,\n                    'message': '证书文件名不存在'\n                }), 400\n                \n            # 源证书路径\n            src_cert = os.path.join(app.config['UPLOAD_DIR'], cert_filename)\n            src_key = os.path.join(app.config['UPLOAD_DIR'], key_filename)\n\n            # 检查源证书文件是否存在\n            if not os.path.exists(src_cert) or not os.path.exists(src_key):\n                print(f\"错误：证书文件不存在，cert存在: {os.path.exists(src_cert)}, key存在: {os.path.exists(src_key)}\")\n                return jsonify({\n                    'success': False,\n                    'message': '证书文件不存在'\n                }), 404\n            # 目标证书路径\n            cert_path = os.path.join(cert_dir, f'{proxy_id}.crt')\n            key_path = os.path.join(cert_dir, f'{proxy_id}.key')\n            print(f\"目标证书路径: {cert_path}\")\n            print(f\"目标私钥路径: {key_path}\")\n\n            # 复制证书文件\n            try:\n                # 如果目标文件已存在，先删除\n                if os.path.exists(cert_path):\n                    os.remove(cert_path)\n                if os.path.exists(key_path):\n                    os.remove(key_path)\n                    \n                shutil.copy2(src_cert, cert_path)\n                print(f\"成功复制证书文件: {src_cert} -> {cert_path}\")\n                shutil.copy2(src_key, key_path)\n                print(f\"成功复制私钥文件: {src_key} -> {key_path}\")\n            except Exception as e:\n                print(f\"复制证书文件时出错: {str(e)}\")\n                return jsonify({\n                    'success': False,\n                    'message': f'复制证书文件失败: {str(e)}'\n                }), 500\n\n        # 解析原始URL和代理URL\n        original_url = proxy_data.get('original_url')\n        proxy_url = proxy_data.get('proxy_url')\n\n        # 提取upstream（去除http://或https://后的地址）\n        upstream = original_url.split('://', 1)[1] if '://' in original_url else original_url\n\n        # 生成toml配置文件内容\n        toml_content = f'''\n# 反向代理配置文件 - {proxy_data.get('service_name')}\n[[host]]\nbind=\"{proxy_url}/\"\ntlscert=\"./cert/{proxy_id}.crt\"\ntlskey=\"./cert/{proxy_id}.key\"\ntarget=\"{original_url}/\"\nupstream=\"{upstream}\"\ntimeout=3000\n'''\n\n        # 保存toml配置文件\n        toml_file_path = os.path.join(toml_dir, f'{proxy_id}.toml')\n        with open(toml_file_path, 'w', encoding='utf-8') as f:\n            f.write(toml_content)\n\n        # 运行反向代理命令\n        proxy_exe = os.path.join(proxy_dir, 'proxy')\n        cmd = [proxy_exe, 'rhttp', '-c', f'./toml/{proxy_id}.toml']\n        print(f\"准备执行命令: {' '.join(cmd)}\")\n        print(f\"工作目录: {proxy_dir}\")\n\n        # 使用subprocess启动进程\n        try:\n            process = subprocess.Popen(cmd, cwd=proxy_dir)\n            print(f\"成功启动进程，PID: {process.pid}\")\n        except Exception as e:\n            print(f\"启动进程失败: {str(e)}\")\n            return jsonify({\n                'success': False,\n                'message': f'启动代理进程失败: {str(e)}'\n            }), 500\n \n        # 更新proxy_data.json中的进程号和状态\n        for proxy in proxies:\n            if proxy.get('id') == proxy_id:\n                proxy['pid'] = process.pid\n                proxy['status'] = 'on'  # 添加状态参数\n                break\n\n        # 保存更新后的proxy_data.json\n        with open(proxy_data_file, 'w', encoding='utf-8') as f:\n            json.dump(proxies, f, ensure_ascii=False, indent=2)\n\n        return jsonify({\n            'success': True,\n            'message': f'反向代理服务 {proxy_id} 已启动',\n            'pid': process.pid\n        })\n\n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'message': f'启动反向代理服务失败：{str(e)}'\n        }), 500\n\n@app.route('/stop_proxy', methods=['POST'])\ndef stop_proxy():\n    try:\n        # 获取要停止的代理ID\n        proxy_id = request.json.get('proxy_id')\n        if not proxy_id:\n            return jsonify({\n                'success': False,\n                'message': '请提供要停止的代理ID'\n            }), 400\n\n        # 构建kill命令\n        cmd = f'kill $(pgrep -f \"rhttp -c ./toml/{proxy_id}.toml\")'\n        \n        # 执行命令获取进程ID\n        result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n        if result.stderr:\n            return jsonify({\n                'success': False,\n                'message': f'获取进程ID失败：{result.stderr}'\n            }), 500\n        \n        # 解析输出获取进程ID\n        output_lines = result.stdout.strip().split('\\n')\n\n        \n        # 获取最后一行的数字作为pid\n        if len(output_lines) > 0:\n            last_line = output_lines[-1].strip()\n            if last_line.isdigit():\n                return jsonify({\n                    'success': True,\n                    'message': '代理服务已停止'\n                })\n        \n        return jsonify({\n            'success': False,\n            'message': '代理服务未找到'\n        }), 404\n        \n    except Exception as e:\n        error_msg = f\"停止反向代理服务失败：{str(e)}\"\n        print(error_msg)\n        return jsonify({\n            'success': False,\n            'message': error_msg\n        }), 500\n\n@app.route('/get_proxy_pid/<service_id>', methods=['GET'])\ndef get_proxy_pid(service_id):\n    try:\n        # 读取proxy_data.json文件获取服务信息\n        proxy_data_file = os.path.join('proxy', 'proxy_data.json')\n        if not os.path.exists(proxy_data_file):\n            return jsonify({'success': True, 'pid': None})\n            \n        with open(proxy_data_file, 'r', encoding='utf-8') as f:\n            proxy_services = json.load(f)\n            \n        # 查找指定服务ID的配置\n        service = next((s for s in proxy_services if s['id'] == service_id), None)\n        if not service:\n            return jsonify({'success': True, 'pid': None})\n            \n        # 构建kill命令\n        cmd = f'pgrep -f \"rhttp -c ./toml/{service_id}.toml\"'\n        \n        # 执行命令获取进程ID\n        result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n        if result.stderr:\n            return jsonify({'success': True, 'pid': None})\n        \n        # 解析输出获取进程ID\n        output_lines = result.stdout.strip().split('\\n')\n\n        \n        # 获取最后一行的数字作为pid\n        if len(output_lines) > 0:\n            last_line = output_lines[-1].strip()\n            if last_line.isdigit():\n                return jsonify({'success': True, 'pid': int(last_line)})\n        \n        return jsonify({'success': True, 'pid': None})\n        \n    except Exception as e:\n        print(f\"发生异常: {str(e)}\")\n        return jsonify({'success': True, 'pid': None})\n\n\ndef auto_start_proxy_services():\n    \"\"\"根据proxy_data.json中的status状态自动启动代理服务\"\"\"\n    try:\n        print(\"正在检查并启动代理服务...\")\n        # 获取代理数据文件路径\n        proxy_data_file = app.config.get('PROXY_DATA_FILE')\n        if not proxy_data_file or not os.path.exists(proxy_data_file):\n            print(\"代理数据文件不存在，跳过自动启动\")\n            return\n            \n        # 读取代理数据\n        with open(proxy_data_file, 'r', encoding='utf-8') as f:\n            proxies = json.load(f)\n            \n        # 设置反向代理工作目录\n        proxy_dir = os.path.join(app.config['BASE_DIR'], 'proxy')\n        toml_dir = os.path.join(proxy_dir, 'toml')\n        cert_dir = os.path.join(proxy_dir, 'cert')\n        \n        # 确保目录存在\n        os.makedirs(toml_dir, exist_ok=True)\n        os.makedirs(cert_dir, exist_ok=True)\n        \n        # 遍历所有代理服务\n        for proxy_data in proxies:\n            # 检查状态是否为on\n            if proxy_data.get('status') != 'on':\n                print(f\"代理服务 {proxy_data.get('id')} 状态为 {proxy_data.get('status')}，跳过启动\")\n                continue\n                \n            proxy_id = proxy_data.get('id')\n            print(f\"准备启动代理服务: {proxy_id}\")\n            \n            # 准备证书文件\n            if proxy_data.get('cert_type') == 'qilin':\n                # 使用qilin证书\n                cert_id = proxy_data.get('cert_id')\n                if not cert_id:\n                    print(f\"代理服务 {proxy_id} 的证书ID不存在，跳过启动\")\n                    continue\n                    \n                # 源证书路径\n                src_cert = os.path.join(app.config['CERTS_DIR'], cert_id, f'{cert_id}.crt')\n                src_key = os.path.join(app.config['CERTS_DIR'], cert_id, f'{cert_id}.key')\n                \n                # 检查源证书文件是否存在\n                if not os.path.exists(src_cert) or not os.path.exists(src_key):\n                    print(f\"代理服务 {proxy_id} 的证书文件不存在，跳过启动\")\n                    continue\n                    \n                # 目标证书路径\n                cert_path = os.path.join(cert_dir, f'{proxy_id}.crt')\n                key_path = os.path.join(cert_dir, f'{proxy_id}.key')\n                \n                # 复制证书文件\n                try:\n                    # 如果目标文件已存在，先删除\n                    if os.path.exists(cert_path):\n                        os.remove(cert_path)\n                    if os.path.exists(key_path):\n                        os.remove(key_path)\n                        \n                    shutil.copy2(src_cert, cert_path)\n                    shutil.copy2(src_key, key_path)\n                except Exception as e:\n                    print(f\"复制证书文件失败: {str(e)}，跳过启动代理服务 {proxy_id}\")\n                    continue\n            else:\n                # 使用自定义证书\n                cert_filename = proxy_data.get('cert_filename')\n                key_filename = proxy_data.get('key_filename')\n                \n                if not cert_filename or not key_filename:\n                    print(f\"代理服务 {proxy_id} 的证书文件名不存在，跳过启动\")\n                    continue\n                    \n                # 源证书路径\n                src_cert = os.path.join(app.config['UPLOAD_DIR'], cert_filename)\n                src_key = os.path.join(app.config['UPLOAD_DIR'], key_filename)\n                \n                # 检查源证书文件是否存在\n                if not os.path.exists(src_cert) or not os.path.exists(src_key):\n                    print(f\"代理服务 {proxy_id} 的证书文件不存在，跳过启动\")\n                    continue\n                    \n                # 目标证书路径\n                cert_path = os.path.join(cert_dir, f'{proxy_id}.crt')\n                key_path = os.path.join(cert_dir, f'{proxy_id}.key')\n                \n                # 复制证书文件\n                try:\n                    # 如果目标文件已存在，先删除\n                    if os.path.exists(cert_path):\n                        os.remove(cert_path)\n                    if os.path.exists(key_path):\n                        os.remove(key_path)\n                        \n                    shutil.copy2(src_cert, cert_path)\n                    shutil.copy2(src_key, key_path)\n                except Exception as e:\n                    print(f\"复制证书文件失败: {str(e)}，跳过启动代理服务 {proxy_id}\")\n                    continue\n            \n            # 解析原始URL和代理URL\n            original_url = proxy_data.get('original_url')\n            proxy_url = proxy_data.get('proxy_url')\n            \n            # 提取upstream（去除http://或https://后的地址）\n            upstream = original_url.split('://', 1)[1] if '://' in original_url else original_url\n            \n            # 生成toml配置文件内容\n            toml_content = f'''\n# 反向代理配置文件 - {proxy_data.get('service_name')}\n[[host]]\nbind=\"{proxy_url}/\"\ntlscert=\"./cert/{proxy_id}.crt\"\ntlskey=\"./cert/{proxy_id}.key\"\ntarget=\"{original_url}/\"\nupstream=\"{upstream}\"\ntimeout=3000\n'''\n            \n            # 保存toml配置文件\n            toml_file_path = os.path.join(toml_dir, f'{proxy_id}.toml')\n            with open(toml_file_path, 'w', encoding='utf-8') as f:\n                f.write(toml_content)\n            \n            # 运行反向代理命令\n            proxy_exe = os.path.join(proxy_dir, 'proxy')\n            cmd = [proxy_exe, 'rhttp', '-c', f'./toml/{proxy_id}.toml']\n            \n            # 使用subprocess启动进程\n            try:\n                process = subprocess.Popen(cmd, cwd=proxy_dir)\n                print(f\"成功启动代理服务 {proxy_id}，PID: {process.pid}\")\n                \n                # 更新proxy_data.json中的进程号\n                for proxy in proxies:\n                    if proxy.get('id') == proxy_id:\n                        proxy['pid'] = process.pid\n                        break\n                \n                # 保存更新后的proxy_data.json\n                with open(proxy_data_file, 'w', encoding='utf-8') as f:\n                    json.dump(proxies, f, ensure_ascii=False, indent=2)\n                    \n            except Exception as e:\n                print(f\"启动代理服务 {proxy_id} 失败: {str(e)}\")\n    except Exception as e:\n        print(f\"自动启动代理服务时出错: {str(e)}\")\n\nif __name__ == '__main__':\n    # 在应用启动前，根据proxy_data.json中的status状态自动启动代理服务\n    auto_start_proxy_services()\n    \n    app.run(host='0.0.0.0', port=2002, debug=True)"}
	],
	"edges":[]
}