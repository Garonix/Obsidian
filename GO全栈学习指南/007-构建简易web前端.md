好的，我们继续旅程！现在，我们的后端API已经非常强大和完备了，但它仍然只是一个“幕后英雄”。为了让普通用户能够使用我们的待办事项应用，我们需要一个“门面”——**前端用户界面 (UI)**。

**下一步：构建一个简约的前端应用来与Go后端交互。**

为了让你能快速上手并专注于“前后端如何协作”这个核心问题，我们将采用以下技术栈：
*   **Vue 3**: 一个对新手极其友好的现代JavaScript框架。
*   **Vite**: 一个快如闪电的前端构建工具。
*   **Axios**: 一个用于发送HTTP请求的流行库。
*   **无需复杂的CSS**: 我们将使用最基础的HTML标签，聚焦于功能实现。

---

### 第一部分：准备前端开发环境

1.  **安装 Node.js**: 前端开发离不开Node.js。请从官网下载并安装LTS（长期支持）版本：[https://nodejs.org/](https://nodejs.org/)。安装Node.js会自动安装`npm`（Node包管理器）。
    *   在终端输入 `node -v` 和 `npm -v` 来验证安装是否成功。

2.  **创建Vue项目**:
    *   **在 `go-hello-server` 的同级目录**（而不是内部）打开一个新的终端窗口。这是为了保持前后端项目分离。
    *   运行以下命令来创建一个新的Vue项目：
        ```bash
        npm create vue@latest
        ```
    *   它会交互式地询问你一些问题：
        *   `Project name`: 输入一个项目名，比如 `todo-frontend`。
        *   后面的选项，如 `TypeScript`, `JSX Support`, `Vue Router`, `Pinia`, `Vitest`, `Cypress`, `ESLint`，**为了保持简单，你可以一路回车选择 "No"**。
    *   创建完成后，根据提示进入项目目录并安装依赖：
        ```bash
        cd todo-frontend
        npm install
        ```

3.  **安装 Axios**:
    *   在 `todo-frontend` 目录下，运行以下命令安装axios：
        ```bash
        npm install axios
        ```

现在的目录结构应该是这样的：
```
(某个父文件夹)/
├── go-hello-server/  (你的Go后端项目)
└── todo-frontend/    (我们刚创建的Vue前端项目)
```

---

### 第二部分：编写前端代码

我们的目标是创建一个简单的页面，包含：
*   一个输入框和“添加”按钮，用于创建新的todo。
*   一个列表，显示所有的todo。
*   每个todo旁边有“更新状态”和“删除”按钮。

1.  **打开前端项目**：用你的代码编辑器（如VS Code）打开 `todo-frontend` 文件夹。

2.  **修改核心文件 `src/App.vue`**:
    *   这个文件是Vue应用的根组件。清空它原来的所有内容，然后将下面的代码完整地粘贴进去。
    *   请仔细阅读代码中的注释，它解释了Vue的基本概念和每一部分的功能。  


```
<script setup>
// --- 1. SCRIPT (逻辑部分) ---
import { ref, onMounted } from 'vue';
import axios from 'axios';

// 定义后端API的基础URL
// 注意：因为前端开发服务器默认在5173端口，后端在8080，这会产生跨域问题
// 我们稍后会通过配置Vite来解决
const API_URL = 'http://localhost:8080/api';

// --- 响应式状态 ---
// ref() 创建一个“响应式引用”，当它的值改变时，模板会自动更新
const todos = ref([]);       // 存储待办事项列表
const newTodoTitle = ref(''); // 绑定到输入框的值

// --- API 调用函数 ---

// 获取所有todos
const fetchTodos = async () => {
  try {
    const response = await axios.get(`${API_URL}/todos`);
    todos.value = response.data; // 更新todos列表
  } catch (error) {
    console.error('获取todos失败:', error);
  }
};

// 添加一个新的todo
const addTodo = async () => {
  if (!newTodoTitle.value.trim()) return; // 不添加空内容
  try {
    const response = await axios.post(`${API_URL}/todos`, {
      title: newTodoTitle.value,
    });
    todos.value.push(response.data); // 将新返回的todo添加到列表中
    newTodoTitle.value = ''; // 清空输入框
  } catch (error) {
    console.error('添加todo失败:', error);
  }
};

// 更新一个todo的状态
const updateTodoStatus = async (todo) => {
  try {
    const newStatus = todo.Status === 'pending' ? 'completed' : 'pending';
    const response = await axios.put(`${API.URL}/todos/${todo.ID}`, {
      status: newStatus,
      title: todo.Title, // GORM的updates需要所有字段，我们保持title不变
    });
    // 更新本地列表中的对应项
    const index = todos.value.findIndex(t => t.ID === todo.ID);
    if (index !== -1) {
      todos.value[index] = response.data;
    }
  } catch (error) {
    console.error('更新todo失败:', error);
  }
};

// 删除一个todo
const deleteTodo = async (id) => {
  try {
    await axios.delete(`${API_URL}/todos/${id}`);
    // 从本地列表中移除
    todos.value = todos.value.filter(t => t.ID !== id);
  } catch (error) {
    console.error('删除todo失败:', error);
  }
};

// --- 生命周期钩子 ---
// onMounted() 会在组件被挂载到页面上后执行
onMounted(() => {
  fetchTodos(); // 页面加载时，自动获取一次数据
});
</script>

<template>
  <!-- 2. TEMPLATE (HTML结构部分) -->
  <div class="todo-app">
    <h1>我的待办事项</h1>

    <!-- 添加新Todo的表单 -->
    <div class="add-todo">
      <input
        v-model="newTodoTitle"
        @keyup.enter="addTodo"
        placeholder="想做点什么？"
      />
      <button @click="addTodo">添加</button>
    </div>

    <!-- Todo列表 -->
    <ul>
      <li v-for="todo in todos" :key="todo.ID" :class="{ completed: todo.Status === 'completed' }">
        <span>{{ todo.Title }}</span>
        <div class="buttons">
          <button @click="updateTodoStatus(todo)">
            {{ todo.Status === 'pending' ? '完成' : '撤销' }}
          </button>
          <button @click="deleteTodo(todo.ID)" class="delete">删除</button>
        </div>
      </li>
    </ul>
  </div>
</template>

<style>
/* --- 3. STYLE (CSS样式部分) --- */
.todo-app {
  max-width: 600px;
  margin: 2rem auto;
  font-family: sans-serif;
}
.add-todo {
  display: flex;
  margin-bottom: 1rem;
}
input {
  flex-grow: 1;
  padding: 0.5rem;
  font-size: 1rem;
}
button {
  padding: 0.5rem 1rem;
  border: none;
  background-color: #42b983;
  color: white;
  cursor: pointer;
}
ul {
  list-style: none;
  padding: 0;
}
li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  border-bottom: 1px solid #ddd;
}
li.completed span {
  text-decoration: line-through;
  color: #888;
}
.buttons button {
  margin-left: 0.5rem;
}
.delete {
  background-color: #e74c3c;
}
</style>
```

3.  **配置Vite解决跨域问题 (CORS)**
    *   在浏览器中，出于安全原因，默认不允许一个源（比如`http://localhost:5173`）的脚本去请求另一个源（`http://localhost:8080`）的资源。这就是**跨域**。
    *   最规范的解决方法是在**后端**设置CORS策略，允许前端的地址访问。我们需要给Gin添加一个CORS中间件。

    a. **回到你的Go后端项目 (`go-hello-server`) 的终端**。
    b. **安装Gin的CORS中间件**:
       ```bash
       go get github.com/gin-contrib/cors
       ```
    c. **修改Go后端的 `main.go` 文件**。在 `r := gin.Default()` 之后，`api := r.Group("/api")` 之前，加入以下代码来使用这个中间件：

```go
       // ... 在 import 中添加 "github.com/gin-contrib/cors"
       
       func main() {
           // ... (数据库连接部分)
           
           r := gin.Default()

           // --- 使用CORS中间件 ---
           config := cors.DefaultConfig()
           config.AllowOrigins = []string{"http://localhost:5173"} // 允许来自前端开发服务器的请求
           config.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
           r.Use(cors.New(config))
           // ----------------------

           api := r.Group("/api")
           // ... (路由定义部分)
           
           r.Run(":8080")
       }
       ```

---

### 第三部分：同时运行前后端并测试

现在，你需要**同时运行后端和前端**。这意味着你需要**两个终端窗口**。

1.  **终端窗口1：启动后端服务器**
    *   进入 `go-hello-server` 目录。
    *   运行 `go run main.go`。

2.  **终端窗口2：启动前端开发服务器**
    *   进入 `todo-frontend` 目录。
    *   运行 `npm run dev`。
    *   终端会显示一个地址，通常是 `http://localhost:5173/`。

3.  **在浏览器中打开前端应用**
    *   访问 `http://localhost:5173/`。
    *   你应该能看到一个标题为“我的待办事项”的页面。
    *   如果后端有数据，列表会自动加载出来。
    *   现在，你可以通过这个界面来**添加、更新和删除**待办事项了！所有的操作都会向你的Go后端发送API请求，并实时更新界面。

**恭喜你！你已经成功构建并运行了一个完整的全栈应用！**

你现在已经亲身体验了：
*   前端如何通过API与后端通信。
*   后端如何处理来自前端的请求并操作数据库。
*   如何处理跨域（CORS）这个在全栈开发中必然会遇到的问题。

你已经走完了从0到1开发一个完整项目的所有核心环节。这绝对是一个里程碑式的成就！