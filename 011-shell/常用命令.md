### 文件和目录操作

* **`ls`**: 列出目录内容
    * `ls`: 列出当前目录的文件和目录
    * `ls -l`:  以长格式列出，显示详细信息 (权限、所有者、大小、日期等)
    * `ls -a`: 列出所有文件，包括隐藏文件 (以 `.` 开头的文件)
    * `ls -h`: 以人类可读的格式显示文件大小 (例如, KB, MB, GB)
    * `ls -t`:  按修改时间排序，最新的文件排在前面
    * `ls -r`:  反向排序
    * `ls -R`:  递归列出子目录的内容
    * `ls 目录路径`: 列出指定目录的内容
    * 示例: `ls -lha /home/user/documents`  列出 `/home/user/documents` 目录下所有文件（包括隐藏文件）的详细信息，并以人类可读的格式显示文件大小。

* **`cd`**: 切换目录 (Change Directory)
    * `cd 目录路径`:  切换到指定的目录
    * `cd`:  切换到用户的主目录 (`home` 目录)
    * `cd ..`:  切换到上一级目录
    * `cd -`:  切换到上一次所在的目录
    * `cd ~`: 切换到用户的主目录 (`home` 目录)
    * 示例: `cd /var/log`  切换到 `/var/log` 目录

* **`pwd`**: 显示当前工作目录 (Print Working Directory)
    * `pwd`:  打印当前你所在的目录的完整路径

* **`mkdir`**: 创建目录 (Make Directory)
    * `mkdir 目录名`:  在当前目录下创建一个新的目录
    * `mkdir -p 目录路径`:  递归创建目录，即使父目录不存在也会自动创建
    * 示例: `mkdir my_project`  在当前目录下创建名为 `my_project` 的目录
    * 示例: `mkdir -p documents/reports/2023`  创建 `documents/reports/2023` 目录，如果 `documents` 或 `reports` 不存在，也会自动创建。

* **`rmdir`**: 删除空目录 (Remove Directory)
    * `rmdir 目录名`:  删除指定的空目录，目录必须为空才能删除。
    * 示例: `rmdir empty_dir`  删除名为 `empty_dir` 的空目录

* **`rm`**: 删除文件或目录 (Remove)
    * `rm 文件名`:  删除指定的文件
    * `rm -r 目录名`:  递归删除目录及其内容 (小心使用，会永久删除!)
    * `rm -f 文件名`:  强制删除文件，忽略不存在的文件和只读文件提示
    * `rm -rf 目录名`: 强制递归删除目录及其内容 (非常危险，谨慎使用!)
    * `rm -i 文件名`:  删除前交互式确认
    * 示例: `rm important_document.txt` 删除 `important_document.txt` 文件
    * 示例: `rm -rf backup_folder`  强制递归删除 `backup_folder` 目录及其所有内容。

* **`cp`**: 复制文件和目录 (Copy)
    * `cp 源文件 目标文件`:  复制文件，将源文件复制到目标文件
    * `cp 源文件 目标目录`:  复制文件，将源文件复制到目标目录中，文件名不变
    * `cp -r 源目录 目标目录`:  递归复制目录，复制整个目录及其内容
    * `cp -i 源文件 目标文件`: 复制前交互式确认，如果目标文件已存在
    * 示例: `cp document.txt backup.txt`  复制 `document.txt` 并命名为 `backup.txt`
    * 示例: `cp -r project_folder backup_folder` 复制 `project_folder` 目录及其内容到 `backup_folder`

* **`mv`**: 移动或重命名文件和目录 (Move)
    * `mv 源文件 目标文件`:  移动文件，同时可以重命名
    * `mv 源文件 目标目录`:  移动文件，将源文件移动到目标目录中，文件名不变
    * `mv 源目录 目标目录`:  移动目录，可以将目录移动到另一个目录中
    * `mv 旧文件名 新文件名`:  重命名文件
    * `mv 旧目录名 新目录名`:  重命名目录
    * `mv -i 源文件 目标文件`:  移动前交互式确认，如果目标文件已存在
    * 示例: `mv report.txt documents/`  将 `report.txt` 移动到 `documents` 目录
    * 示例: `mv old_name.txt new_name.txt`  将 `old_name.txt` 重命名为 `new_name.txt`

* **`touch`**: 创建空文件或更新文件时间戳
    * `touch 文件名`:  创建空文件，如果文件已存在，则更新文件的访问和修改时间。
    * 示例: `touch new_file.txt` 创建一个名为 `new_file.txt` 的空文件。

### 文件内容查看和编辑

* **`cat`**: 连接并显示文件内容 (concatenate)
    * `cat 文件名`:  显示文件内容到终端，通常用于显示短文件
    * `cat 文件1 文件2`:  将多个文件连接起来显示
    * 示例: `cat my_script.sh`  显示 `my_script.sh` 文件的内容

* **`more`**: 分页显示文件内容
    * `more 文件名`:  分页显示文件内容，按空格键翻页，按 `q` 键退出
    * 示例: `more large_file.txt`  分页显示 `large_file.txt` 的内容

* **`less`**:  更强大的分页显示文件内容
    * `less 文件名`:  分页显示文件内容，可以使用上下方向键滚动，按 `q` 键退出，功能比 `more` 更强大
    * 示例: `less very_long_log.log`  分页显示 `very_long_log.log` 的内容，可以上下滚动

* **`head`**: 显示文件开头几行
    * `head 文件名`:  显示文件的前 10 行
    * `head -n 行数 文件名`:  显示文件的前 N 行
    * 示例: `head -n 5 config.ini`  显示 `config.ini` 文件的前 5 行

* **`tail`**: 显示文件末尾几行
    * `tail 文件名`:  显示文件的后 10 行
    * `tail -n 行数 文件名`:  显示文件的后 N 行
    * `tail -f 文件名`:  实时跟踪文件末尾新增加的内容，常用于查看日志文件，按 Ctrl+C 停止
    * 示例: `tail -f application.log`  实时显示 `application.log` 文件新增加的内容

* **`echo`**:  打印输出文本
    * `echo "文本"`:  将文本输出到终端
    * `echo 变量`:  输出变量的值
    * `echo "文本" > 文件名`:  将文本输出重定向到文件，覆盖文件内容
    * `echo "文本" >> 文件名`: 将文本追加到文件末尾
    * 示例: `echo "Hello, Shell!"`  在终端输出 "Hello, Shell!"
    * 示例: `echo $HOME`  输出 `$HOME` 环境变量的值 (通常是用户的主目录)

* **`vim` / `nano` / `emacs`**:  文本编辑器
    * `vim 文件名`: 使用 `vim` 编辑器打开文件 (Vi IMproved)，功能强大，学习曲线较陡峭
    * `nano 文件名`: 使用 `nano` 编辑器打开文件，简单易用，适合新手
    * `emacs 文件名`: 使用 `emacs` 编辑器打开文件，功能非常强大，但较为复杂 (Emacs Macros)
    * 示例: `vim my_script.sh`  使用 `vim` 编辑器打开 `my_script.sh` 文件进行编辑

* **`grep`**:  在文件中搜索文本 (Global Regular Expression Print)
    * `grep "关键词" 文件名`:  在文件中搜索包含 "关键词" 的行并显示
    * `grep -i "关键词" 文件名`:  忽略大小写搜索
    * `grep -r "关键词" 目录`:  递归搜索目录下的所有文件
    * `grep -v "关键词" 文件名`:  显示不包含 "关键词" 的行
    * `grep -n "关键词" 文件名`:  显示匹配行的行号
    * `grep -c "关键词" 文件名`:  只显示匹配的行数
    * `grep -l "关键词" 文件名`:  只显示包含匹配项的文件名
    * 示例: `grep "error" application.log`  在 `application.log` 文件中搜索包含 "error" 的行
    * 示例: `grep -r "function_name" project_folder`  在 `project_folder` 目录及其子目录的所有文件中搜索包含 "function_name" 的行。

* **`sed`**:  流编辑器 (Stream Editor)
    * `sed 's/旧文本/新文本/g' 文件名`:  替换文件中的文本，`s` 表示替换命令，`g` 表示全局替换 (替换所有匹配项)
    * `sed -i 's/旧文本/新文本/g' 文件名`:  直接修改文件内容 (in-place editing)，替换文件中的文本
    * 示例: `sed 's/apple/orange/g' fruits.txt`  将 `fruits.txt` 文件中所有 "apple" 替换为 "orange"，并将结果输出到终端 (不会修改原文件)
    * 示例: `sed -i 's/color/colour/g' document.txt`  直接修改 `document.txt` 文件，将所有 "color" 替换为 "colour"。

* **`awk`**:  文本处理工具 (Aho, Weinberger, Kernighan)
    * `awk '{print $1}' 文件名`:  打印文件的第一列 (`$1` 表示第一列，`$2` 表示第二列，以此类推，`$0` 表示整行)
    * `awk -F ',' '{print $2}' 文件名`:  使用逗号 `,` 作为分隔符，打印第二列
    * `awk '/关键词/ {print $0}' 文件名`:  打印包含 "关键词" 的行
    * 示例: `awk '{print $3}' data.csv`  打印 `data.csv` 文件的第三列 (默认以空格或制表符分隔)
    * 示例: `awk -F ':' '{print $1":"$3}' /etc/passwd`  以冒号 `:` 分隔，打印 `/etc/passwd` 文件的第一列和第三列，并用冒号连接。

* **`diff`**:  比较文件差异 (Difference)
    * `diff 文件1 文件2`:  比较两个文件的不同之处，显示差异的行
    * `diff -u 文件1 文件2`:  以统一格式 (unified format) 显示差异，常用于生成补丁文件 (patch file)
    * 示例: `diff old_version.txt new_version.txt`  比较 `old_version.txt` 和 `new_version.txt` 文件的差异

* **`wc`**:  统计文件字数 (Word Count)
    * `wc 文件名`:  统计文件的行数、单词数和字节数，并显示文件名
    * `wc -l 文件名`:  只统计文件的行数 (lines)
    * `wc -w 文件名`:  只统计文件的单词数 (words)，以空格、制表符或换行符分隔
    * `wc -c 文件名`:  只统计文件的字节数 (bytes)
    * `wc -m 文件名`:  只统计文件的字符数 (characters)，对于多字节字符 (如中文)，字符数和字节数可能不同
    * `wc -L 文件名`:  统计文件中最长行的长度 (length of longest line)
    * 示例: `wc my_document.txt`  统计 `my_document.txt` 文件的行数、单词数和字节数
    * 示例: `wc -l *.txt`  统计当前目录下所有 `.txt` 文件的行数总和

* **`sort`**:  对文本文件内容进行排序
    * `sort 文件名`:  对文件内容按行进行排序，默认按字典顺序升序排列，并将排序结果输出到终端 (不修改原文件)
    * `sort -n 文件名`:  按数值大小排序 (numeric sort)，适用于包含数字的文本行
    * `sort -r 文件名`:  倒序排序 (reverse sort)，降序排列
    * `sort -k 列号 文件名`:  按指定列进行排序 (key)，列号从 1 开始，默认列分隔符为空格或制表符
    * `sort -t 分隔符 -k 列号 文件名`:  使用指定分隔符 (delimiter) 分隔列
    * `sort -u 文件名`:  排序后去除重复行 (unique)，只输出唯一的行
    * `sort -f 文件名`:  排序时忽略大小写 (fold case)
    * 示例: `sort names.txt`  对 `names.txt` 文件内容按字母顺序排序
    * 示例: `sort -n numbers.txt`  对 `numbers.txt` 文件内容按数字大小排序
    * 示例: `sort -t ',' -k 2 data.csv`  对 `data.csv` 文件按逗号分隔的第二列进行排序

* **`uniq`**:  去除文本文件中重复的行 (unique)
    * `uniq 文件名`:  去除文件中的连续重复行，只输出唯一的行，但只对**相邻**的重复行有效，使用前通常需要先用 `sort` 排序
    * `uniq -c 文件名`:  在每行前面显示该行重复出现的次数 (count)
    * `uniq -d 文件名`:  只显示重复的行 (duplicate lines)
    * `uniq -u 文件名`:  只显示不重复的行 (unique lines)
    * `uniq -i 文件名`:  比较时忽略大小写 (ignore case)
    * 示例: `sort lines.txt | uniq`  先排序 `lines.txt` 文件，再去除重复行并输出
    * 示例: `uniq -c sorted_lines.txt`  统计 `sorted_lines.txt` 文件中每行重复出现的次数

* **`cut`**:  按列截取文件内容
    * `cut -f 列号 文件名`:  截取文件的指定列 (fields)，默认列分隔符为制表符
    * `cut -f 列号1,列号2 文件名`:  截取文件的多个指定列
    * `cut -f 列号范围 文件名`:  截取文件的指定列范围，例如 `1-3` 表示第 1 到 3 列
    * `cut -d 分隔符 -f 列号 文件名`:  使用指定分隔符 (delimiter) 分隔列，例如 `-d ','` 表示使用逗号作为分隔符
    * `cut -c 字符位置 文件名`:  按字符位置截取，例如 `-c 1-5` 表示截取每行的第 1 到 5 个字符
    * 示例: `cut -f 1 data.txt`  截取 `data.txt` 文件的第一列 (默认以制表符分隔)
    * 示例: `cut -d ',' -f 2,3 data.csv`  截取 `data.csv` 文件中以逗号分隔的第二列和第三列

* **`paste`**:  合并文件行
    * `paste 文件1 文件2`:  将多个文件的行按列合并，默认以制表符分隔
    * `paste -d 分隔符 文件1 文件2`:  使用指定分隔符 (delimiter) 连接文件列
    * `paste -s 文件名`:  将一个文件的多行合并成一行 (串行 paste)
    * 示例: `paste names.txt ages.txt`  将 `names.txt` 和 `ages.txt` 文件的内容按列合并
    * 示例: `paste -d ',' file1.txt file2.txt file3.txt`  将三个文件内容按列合并，并用逗号分隔

* **`comm`**:  比较两个已排序文件的异同 (compare)
    * `comm 文件1 文件2`:  比较两个已排序的文件，输出三列：第一列为文件 1 独有的行，第二列为文件 2 独有的行，第三列为两个文件共有的行
    * `comm -1 文件1 文件2`:  不显示文件 1 独有的行 (suppress column 1)
    * `comm -2 文件1 文件2`:  不显示文件 2 独有的行 (suppress column 2)
    * `comm -3 文件1 文件2`:  不显示两个文件共有的行 (suppress column 3)
    * `comm -12 文件1 文件2`:  只显示两个文件共有的行 (同时不显示文件 1 和文件 2 独有的行)
    * 示例: `comm sorted_file1.txt sorted_file2.txt`  比较 `sorted_file1.txt` 和 `sorted_file2.txt` 文件的异同

* **`nl`**:  给文件内容添加行号 (number lines)
    * `nl 文件名`:  给文件内容添加行号并显示，默认行号从 1 开始，输出格式可配置
    * `nl -b a 文件名`:  所有行都添加行号 (body lines numbering style: a - all lines)
    * `nl -b t 文件名`:  只给文本行添加行号 (body lines numbering style: t - nonempty lines, default)
    * `nl -n ln 文件名`:  行号格式为左对齐 (number format: ln - left-justified, rn - right-justified, rz - right-justified zero-padded)
    * `nl -w 宽度 文件名`:  设置行号的宽度 (number width)
    * `nl -s 分隔符 文件名`:  设置行号和文本之间的分隔符 (separator)
    * 示例: `nl my_text_file.txt`  给 `my_text_file.txt` 文件内容添加行号并显示

* **`split`**:  分割文件
    * `split 文件名`:  将文件分割成多个小文件，默认以 `xaa`, `xab`, `xac` ... 命名，每个文件 1000 行
    * `split -l 行数 文件名`:  按行数分割文件，每个文件包含指定的行数
    * `split -b 字节数 文件名`:  按字节大小分割文件，每个文件大小不超过指定的字节数，可以使用单位 (例如 `k`, `m`, `g`)
    * `split -d 文件名 前缀名`:  分割后的文件后缀使用数字 (numeric suffix)，例如 `前缀名01`, `前缀名02`, `前缀名03` ...
    * `split -a 长度 文件名 前缀名`:  指定后缀的长度 (suffix length)
    * 示例: `split large_file.txt`  将 `large_file.txt` 文件分割成多个小文件，默认前缀为 `x`
    * 示例: `split -l 500 big_data.csv chunk_`  将 `big_data.csv` 文件按每 500 行分割，文件前缀名为 `chunk_`，后缀为数字
### 进程管理

* **`ps`**:  显示进程状态 (Process Status)
    * `ps`:  显示当前用户的进程
    * `ps aux`:  显示所有用户的详细进程信息 (a: all users, u: user-oriented format, x: processes without controlling terminal)
    * `ps -ef`:  另一种显示所有进程的格式 (e: every process, f: full format listing)
    * `ps aux | grep 进程名`:  查找特定进程名的进程
    * 示例: `ps aux | grep firefox`  查找所有包含 "firefox" 关键词的进程

* **`top`**:  实时显示系统资源占用和进程状态
    * `top`:  实时动态显示系统中 CPU、内存等资源的使用情况，以及各个进程的资源占用情况，按 `q` 键退出

* **`htop`**:  交互式进程查看器 (需要安装，比 `top` 更友好，可以使用鼠标操作)
    * `htop`:  启动 `htop` 交互式进程查看器，提供更友好的界面和操作方式

* **`kill`**:  终止进程
    * `kill 进程ID`:  向指定进程 ID 的进程发送 SIGTERM 信号 (默认信号)，请求进程正常终止
    * `kill -9 进程ID`:  向指定进程 ID 的进程发送 SIGKILL 信号 (强制终止信号)，强制立即终止进程 (不建议常用，可能导致数据丢失)
    * `killall 进程名`:  根据进程名终止所有匹配的进程
    * 示例: `kill 12345`  终止进程 ID 为 12345 的进程
    * 示例: `killall firefox`  终止所有名为 `firefox` 的进程

* **`bg`**:  将进程放到后台运行 (Background)
    * `bg 作业号`:  将挂起的作业放到后台继续运行，作业号可以使用 `jobs` 命令查看

* **`fg`**:  将后台进程放到前台运行 (Foreground)
    * `fg 作业号`:  将后台运行的作业放到前台运行，作业号可以使用 `jobs` 命令查看

* **`jobs`**:  显示当前会话的作业状态
    * `jobs`:  列出当前会话中正在后台运行或挂起的作业，显示作业号和状态

* **`&`**:  将命令放到后台运行
    * `命令 &`:  在命令末尾添加 `&` 符号，使命令在后台运行
    * 示例: `long_running_script.sh &`  将 `long_running_script.sh` 脚本放到后台运行

* **`nohup`**:  忽略挂断信号运行程序 (No Hang Up)
    * `nohup 命令 &`:  使命令在后台运行，并且忽略终端关闭或会话断开的挂断信号，即使终端关闭，程序也会继续运行，输出信息默认重定向到 `nohup.out` 文件
    * 示例: `nohup backup_process.sh &`  使 `backup_process.sh` 脚本在后台运行，即使终端关闭也会继续运行。

* **`screen` / `tmux`**:  终端复用器
    * `screen`:  启动 `screen` 会话，可以在一个 `screen` 会话中创建多个虚拟终端窗口，即使终端断开，`screen` 会话也会保持运行，下次连接时可以恢复会话。
    * `tmux`:  功能更强大的终端复用器，与 `screen` 类似，但功能更丰富，例如可以分屏、窗口管理等。
    * 使用 `screen` 或 `tmux` 可以方便地在后台运行程序，并保持会话，即使网络断开或终端关闭，程序也能继续运行，下次连接时可以恢复会话。

### 系统信息

* **`uname`**:  显示系统信息 (Unix name)
    * `uname`:  显示操作系统内核名称
    * `uname -a`:  显示所有系统信息 (内核名、主机名、内核版本、硬件架构、操作系统类型等)
    * `uname -r`:  显示内核版本
    * `uname -m`:  显示硬件架构 (例如 x86_64, i686)
    * `uname -s`:  显示内核名称
    * 示例: `uname -a`  显示完整的系统信息

* **`hostname`**:  显示或设置主机名
    * `hostname`:  显示当前主机名
    * `hostname 新主机名`:  临时设置主机名 (重启后失效)
    * `hostname -f`:  显示完整域名 (Fully Qualified Domain Name)

* **`date`**:  显示或设置系统日期和时间
    * `date`:  显示当前系统日期和时间
    * `date "+%Y-%m-%d %H:%M:%S"`:  自定义日期时间格式 (例如, `2023-10-27 15:30:00`)
    * `date -s "YYYY-MM-DD HH:MM:SS"`:  设置系统日期和时间 (需要 root 权限)

* **`cal`**:  显示日历 (Calendar)
    * `cal`:  显示当前月份的日历
    * `cal 月份 年份`:  显示指定月份和年份的日历
    * `cal -y 年份`:  显示指定年份的全年日历

* **`df`**:  显示磁盘空间使用情况 (Disk Free)
    * `df`:  显示所有已挂载的文件系统的磁盘空间使用情况 (默认单位为 KB)
    * `df -h`:  以人类可读的格式显示磁盘空间使用情况 (例如, KB, MB, GB, TB)
    * `df -T`:  显示文件系统类型
    * `df -i`:  显示 inode 使用情况 (inode 是用于存储文件元数据的索引节点)
    * 示例: `df -h`  以人类可读的格式显示磁盘空间使用情况

* **`du`**:  显示目录或文件占用磁盘空间 (Disk Usage)
    * `du 目录或文件名`:  显示目录或文件占用的磁盘空间 (默认单位为 KB)
    * `du -h 目录或文件名`:  以人类可读的格式显示磁盘空间占用情况
    * `du -s 目录`:  汇总显示目录的总大小 (Summary)
    * `du -sh 目录`:  汇总显示目录的总大小，并以人类可读的格式显示
    * `du -a 目录`:  显示目录及其所有子目录和文件的磁盘空间占用情况 (all files and directories)
    * `du -c 目录`:  在 `du -a` 的基础上，最后显示总计 (Grand total)
    * `du --max-depth=N 目录`:  限制目录的递归深度为 N 层
    * 示例: `du -sh /home/user/documents`  汇总显示 `/home/user/documents` 目录的总大小，并以人类可读的格式显示

* **`free`**:  显示内存和交换空间使用情况
    * `free`:  显示内存和交换空间的使用情况 (默认单位为 KB)
    * `free -h`:  以人类可读的格式显示内存和交换空间使用情况 (例如, KB, MB, GB)
    * `free -m`:  以 MB 为单位显示内存和交换空间使用情况
    * `free -g`:  以 GB 为单位显示内存和交换空间使用情况
    * 示例: `free -h`  以人类可读的格式显示内存和交换空间使用情况

* **`whoami`**:  显示当前用户名 (Who am I)
    * `whoami`:  显示当前登录用户的用户名

* **`w` / `who`**:  显示当前登录用户的信息
    * `w`:  显示当前登录用户及其正在执行的进程等信息
    * `who`:  显示当前登录用户的用户名、登录终端、登录时间等信息

* **`uptime`**:  显示系统运行时间及平均负载
    * `uptime`:  显示系统已经运行了多长时间，以及系统平均负载 (load average，即单位时间内运行队列中的平均进程数)

* **`lscpu`**:  显示 CPU 架构信息 (List CPU)
    * `lscpu`:  显示 CPU 的详细信息，包括架构、型号、核心数、线程数、缓存大小等 (需要安装 `util-linux` 包)

* **`lspci`**:  显示 PCI 设备信息 (List PCI)
    * `lspci`:  显示系统中的 PCI 总线和设备信息，例如显卡、网卡、硬盘控制器等 (需要安装 `pciutils` 包)

* **`lsusb`**:  显示 USB 设备信息 (List USB)
    * `lsusb`:  显示系统中的 USB 设备信息，例如 USB 鼠标、键盘、U 盘等 (需要安装 `usbutils` 包)

* **`ifconfig` / `ip addr`**:  显示或配置网络接口信息
    * `ifconfig`:  显示或配置网络接口信息 (老旧命令，可能在某些新系统中已被 `ip addr` 替代)
    * `ip addr`:  显示网络接口信息 (推荐使用，功能更强大)
    * `ifconfig 网络接口名`:  显示指定网络接口的信息
    * `ip addr show 网络接口名`:  显示指定网络接口的信息 (更推荐使用)
    * `ifconfig 网络接口名 IP地址 netmask 子网掩码`:  配置网络接口的 IP 地址和子网掩码 (需要 root 权限)
    * `ip addr add IP地址/子网掩码 dev 网络接口名`: 配置网络接口的 IP 地址和子网掩码 (更推荐使用，需要 root 权限)
    * 示例: `ifconfig eth0`  显示 `eth0` 网络接口的信息
    * 示例: `ip addr show eth0`  显示 `eth0` 网络接口的信息 (推荐)

* **`netstat` / `ss`**:  显示网络连接、路由表、接口统计等网络信息
    * `netstat`:  显示网络连接、路由表、接口统计等网络信息 (老旧命令，可能在某些新系统中已被 `ss` 替代)
    * `ss`:  显示 socket 统计信息 (Socket Statistics)，功能比 `netstat` 更强大，推荐使用
    * `netstat -tulnp`:  显示 TCP 和 UDP 监听端口 (t: tcp, u: udp, l: listening, n: numeric address, p: program/pid)
    * `ss -tulnp`:  显示 TCP 和 UDP 监听端口 (功能与 `netstat -tulnp` 类似，但更强大)
    * `netstat -rn`:  显示路由表
    * `ss -r`:  显示路由表 (功能与 `netstat -rn` 类似，但更强大)
    * 示例: `netstat -tulnp`  显示 TCP 和 UDP 监听端口
    * 示例: `ss -tulnp`  显示 TCP 和 UDP 监听端口 (推荐)

* **`ping`**:  测试网络连通性 (Packet InterNet Groper)
    * `ping 主机名或IP地址`:  向目标主机发送 ICMP echo 请求，测试网络连通性，按 Ctrl+C 停止
    * `ping -c 次数 主机名或IP地址`:  指定发送 ICMP echo 请求的次数
    * 示例: `ping www.google.com`  测试到 `www.google.com` 的网络连通性

* **`traceroute` / `tracepath`**:  追踪网络路由 (Trace Route)
    * `traceroute 主机名或IP地址`:  追踪数据包到达目标主机所经过的路由节点
    * `tracepath 主机名或IP地址`:  与 `traceroute` 类似，但使用 UDP 协议，并尝试发现到目标路径的最大传输单元 MTU (Maximum Transmission Unit)
    * 示例: `traceroute www.baidu.com`  追踪到 `www.baidu.com` 的网络路由

* **`dig` / `nslookup`**:  DNS 查询工具 (Domain Information Groper / Name Server Lookup)
    * `dig 域名`:  进行 DNS 查询，显示域名的 DNS 记录信息 (例如 A 记录、MX 记录、NS 记录等)，功能强大
    * `nslookup 域名`:  进行 DNS 查询，显示域名的 DNS 记录信息，功能相对简单
    * `dig 域名 类型`:  查询指定类型的 DNS 记录，例如 `dig www.google.com MX`  查询 `www.google.com` 的 MX 记录
    * 示例: `dig www.example.com`  查询 `www.example.com` 的 DNS 记录信息

* **`curl` / `wget`**:  下载文件 (Client URL / Web Get)
    * `curl URL`:  使用 `curl` 下载 URL 指定的资源，并将内容输出到终端 (默认)
    * `curl -O URL`:  使用 `curl` 下载 URL 指定的资源，并保存为与 URL 中文件名相同的文件 (`-O` 大写字母 O)
    * `curl -o 保存文件名 URL`:  使用 `curl` 下载 URL 指定的资源，并保存为指定的 `保存文件名`
    * `wget URL`:  使用 `wget` 下载 URL 指定的资源，并保存为与 URL 中文件名相同的文件 (默认)
    * `wget -O 保存文件名 URL`:  使用 `wget` 下载 URL 指定的资源，并保存为指定的 `保存文件名`
    * `wget -c URL`:  断点续传，对于未下载完成的文件，可以从上次断开的位置继续下载 (continue)
    * 示例: `curl -O https://example.com/document.pdf`  下载 `https://example.com/document.pdf` 并保存为 `document.pdf`
    * 示例: `wget https://example.com/image.jpg`  下载 `https://example.com/image.jpg` 并保存为 `image.jpg`

### 压缩和解压缩

* **`tar`**:  打包和压缩 (Tape Archive)
    * **打包 (创建归档文件)**
        * `tar -cvf 归档文件名.tar 文件或目录`:  创建 `tar` 归档文件 (c: create, v: verbose, f: file)
        * 示例: `tar -cvf my_archive.tar documents images`  将 `documents` 和 `images` 目录打包成 `my_archive.tar` 文件
    * **解包 (解压归档文件)**
        * `tar -xvf 归档文件名.tar`:  解压 `tar` 归档文件到当前目录 (x: extract)
        * `tar -xvf 归档文件名.tar -C 目标目录`:  解压 `tar` 归档文件到指定的 `目标目录` (C: directory)
        * 示例: `tar -xvf my_archive.tar`  解压 `my_archive.tar` 文件到当前目录
    * **打包并使用 gzip 压缩 (创建 .tar.gz 或 .tgz 文件)**
        * `tar -czvf 归档文件名.tar.gz 文件或目录`:  创建 `tar.gz` 压缩包 (z: gzip)
        * 示例: `tar -czvf my_archive.tar.gz project_folder`  将 `project_folder` 目录打包并使用 gzip 压缩成 `my_archive.tar.gz` 文件
    * **解压 .tar.gz 或 .tgz 文件**
        * `tar -xzvf 归档文件名.tar.gz`:  解压 `tar.gz` 压缩包到当前目录
        * `tar -xzvf 归档文件名.tar.gz -C 目标目录`: 解压 `tar.gz` 压缩包到指定的 `目标目录`
        * 示例: `tar -xzvf my_archive.tar.gz`  解压 `my_archive.tar.gz` 文件到当前目录
    * **打包并使用 bzip2 压缩 (创建 .tar.bz2 文件)**
        * `tar -cjvf 归档文件名.tar.bz2 文件或目录`:  创建 `tar.bz2` 压缩包 (j: bzip2)
        * 示例: `tar -cjvf my_archive.tar.bz2 data_files`  将 `data_files` 目录打包并使用 bzip2 压缩成 `my_archive.tar.bz2` 文件
    * **解压 .tar.bz2 文件**
        * `tar -xjvf 归档文件名.tar.bz2`:  解压 `tar.bz2` 压缩包到当前目录
        * `tar -xjvf 归档文件名.tar.bz2 -C 目标目录`: 解压 `tar.bz2` 压缩包到指定的 `目标目录`
        * 示例: `tar -xjvf my_archive.tar.bz2`  解压 `my_archive.tar.bz2` 文件到当前目录
    * **列出 .tar 或 .tar.gz 等归档文件内容 (不解压)**
        * `tar -tvf 归档文件名.tar`:  列出 `tar` 归档文件内容 (t: list)
        * `tar -tzvf 归档文件名.tar.gz`:  列出 `tar.gz` 压缩包内容
        * `tar -tjvf 归档文件名.tar.bz2`:  列出 `tar.bz2` 压缩包内容
        * 示例: `tar -tvf my_archive.tar`  列出 `my_archive.tar` 文件包含的文件列表

* **`gzip` / `gunzip`**:  gzip 压缩和解压缩
    * **压缩**
        * `gzip 文件名`:  使用 gzip 压缩文件，压缩后源文件会被替换为 `.gz` 压缩文件
        * 示例: `gzip log_file.log`  将 `log_file.log` 压缩为 `log_file.log.gz`
    * **解压缩**
        * `gunzip 压缩文件名.gz`:  解压 `.gz` 压缩文件，解压后压缩文件会被替换为源文件
        * `gzip -d 压缩文件名.gz`:  与 `gunzip` 命令效果相同，解压 `.gz` 文件
        * 示例: `gunzip log_file.log.gz`  解压 `log_file.log.gz` 为 `log_file.log`

* **`bzip2` / `bunzip2`**:  bzip2 压缩和解压缩
    * **压缩**
        * `bzip2 文件名`:  使用 bzip2 压缩文件，压缩后源文件会被替换为 `.bz2` 压缩文件，bzip2 通常比 gzip 压缩率更高，但速度较慢
        * 示例: `bzip2 large_image.png`  将 `large_image.png` 压缩为 `large_image.png.bz2`
    * **解压缩**
        * `bunzip2 压缩文件名.bz2`:  解压 `.bz2` 压缩文件，解压后压缩文件会被替换为源文件
        * `bzip2 -d 压缩文件名.bz2`:  与 `bunzip2` 命令效果相同，解压 `.bz2` 文件
        * 示例: `bunzip2 large_image.png.bz2`  解压 `large_image.png.bz2` 为 `large_image.png`

* **`zip` / `unzip`**:  zip 压缩和解压缩
    * **压缩**
        * `zip 压缩文件名.zip 文件或目录`:  创建 `zip` 压缩包
        * 示例: `zip my_zip_archive.zip documents scripts`  将 `documents` 和 `scripts` 目录压缩成 `my_zip_archive.zip` 文件
    * **解压缩**
        * `unzip 压缩文件名.zip`:  解压 `zip` 压缩包到当前目录
        * `unzip 压缩文件名.zip -d 目标目录`:  解压 `zip` 压缩包到指定的 `目标目录` (d: directory)
        * 示例: `unzip my_zip_archive.zip`  解压 `my_zip_archive.zip` 文件到当前目录

* **`xz` / `unxz`**:  xz 压缩和解压缩
    * **压缩**
        * `xz 文件名`:  使用 xz 压缩文件，压缩后源文件会被替换为 `.xz` 压缩文件，xz 压缩率通常比 gzip 和 bzip2 更高，但速度更慢，解压速度也较慢
        * 示例: `xz very_large_data.dat`  将 `very_large_data.dat` 压缩为 `very_large_data.dat.xz`
    * **解压缩**
        * `unxz 压缩文件名.xz`:  解压 `.xz` 压缩文件，解压后压缩文件会被替换为源文件
        * `xz -d 压缩文件名.xz`:  与 `unxz` 命令效果相同，解压 `.xz` 文件
        * 示例: `unxz very_large_data.dat.xz`  解压 `very_large_data.dat.xz` 为 `very_large_data.dat`


### 用户和权限管理

* **`sudo`**:  以超级用户 (root) 权限执行命令 (Super User Do)
    * `sudo 命令`:  以 root 用户的身份执行指定的命令，需要输入当前用户的密码 (如果是第一次或一段时间后)
    * 示例: `sudo apt update`  以 root 权限执行 `apt update` 命令，用于更新系统软件包列表

* **`su`**:  切换用户 (Switch User)
    * `su 用户名`:  切换到指定用户，如果不指定用户名，默认切换到 root 用户，需要输入目标用户的密码 (如果是 root 用户，通常不需要密码)
    * `su - 用户名`:  切换到指定用户，并加载目标用户的环境变量 (更完整地切换用户环境)
    * 示例: `su root`  切换到 root 用户

* **`chmod`**:  修改文件或目录权限 (Change Mode)
    * `chmod 权限 文件或目录`:  修改文件或目录的权限，权限可以使用数字或符号表示
        * **数字表示法 (3位八进制数)**:  每一位分别表示所有者 (user)、所属组 (group)、其他用户 (others) 的权限，每一位的值为 0-7 的数字，分别代表不同的权限组合
            * `0`:  --- (没有任何权限)
            * `1`:  --x (执行权限)
            * `2`:  -w- (写入权限)
            * `3`:  -wx (写入和执行权限)
            * `4`:  r-- (读取权限)
            * `5`:  r-x (读取和执行权限)
            * `6`:  rw- (读取和写入权限)
            * `7`:  rwx (读取、写入和执行权限)
            * 示例: `chmod 755 script.sh`  将 `script.sh` 文件的权限设置为 `rwxr-xr-x` (所有者: 读写执行, 所属组: 读执行, 其他用户: 读执行)
        * **符号表示法**:  使用 `u` (user/owner), `g` (group), `o` (others), `a` (all) 表示用户类型，使用 `+` (添加权限), `-` (移除权限), `=` (设置权限) 表示操作，使用 `r` (read), `w` (write), `x` (execute) 表示权限类型
            * 示例: `chmod u+x script.sh`  给 `script.sh` 文件的所有者添加执行权限
            * 示例: `chmod g-w data.txt`  移除 `data.txt` 文件所属组的写入权限
            * 示例: `chmod o=r 目录名`  设置 `目录名` 目录其他用户的权限为只读
            * 示例: `chmod a+r 文件名`  给所有用户 (所有者、所属组、其他用户) 添加读取权限

* **`chown`**:  修改文件或目录的所有者 (Change Owner)
    * `chown 用户名 文件或目录`:  修改文件或目录的所有者为指定的用户
    * `chown 用户名:组名 文件或目录`:  同时修改文件或目录的所有者和所属组
    * `chown -R 用户名 目录`:  递归修改目录及其所有子目录和文件的所有者
    * 示例: `chown john document.txt`  将 `document.txt` 文件的所有者修改为 `john` 用户
    * 示例: `chown root:root system_config.ini`  将 `system_config.ini` 文件的所有者和所属组都修改为 `root`

* **`chgrp`**:  修改文件或目录的所属组 (Change Group)
    * `chgrp 组名 文件或目录`:  修改文件或目录的所属组为指定的组
    * `chgrp -R 组名 目录`:  递归修改目录及其所有子目录和文件的所属组
    * 示例: `chgrp developers project_folder`  将 `project_folder` 目录的所属组修改为 `developers` 组

* **`useradd`**:  创建新用户 (User Add)
    * `useradd 用户名`:  创建新用户，通常需要 root 权限
    * `useradd -m 用户名`:  创建新用户，并同时创建用户的主目录 (home directory)
    * `useradd -g 组名 用户名`:  创建新用户，并将其添加到指定的组
    * 示例: `sudo useradd -m newuser`  创建名为 `newuser` 的新用户，并创建主目录

* **`userdel`**:  删除用户 (User Delete)
    * `userdel 用户名`:  删除用户，但通常会保留用户的主目录和用户文件
    * `userdel -r 用户名`:  删除用户，并同时删除用户的主目录和用户文件 (recursive)
    * 示例: `sudo userdel -r olduser`  删除 `olduser` 用户及其主目录和用户文件 (小心使用，会永久删除用户数据!)

* **`passwd`**:  修改用户密码 (Password)
    * `passwd 用户名`:  修改指定用户的密码，如果不指定用户名，则修改当前用户的密码
    * 示例: `passwd john`  修改 `john` 用户的密码 (需要以 root 或 john 用户身份执行)

* **`groupadd`**:  创建新用户组 (Group Add)
    * `groupadd 组名`:  创建新用户组，通常需要 root 权限
    * 示例: `sudo groupadd developers`  创建名为 `developers` 的新用户组

* **`groupdel`**:  删除用户组 (Group Delete)
    * `groupdel 组名`:  删除用户组，通常需要 root 权限，如果要删除的组是用户的主组，需要先修改用户的默认组
    * 示例: `sudo groupdel testgroup`  删除名为 `testgroup` 的用户组 (小心使用，如果该组仍然被用户使用，可能会导致问题)

* **`id`**:  显示用户和组 ID 信息 (ID)
    * `id 用户名`:  显示指定用户的用户 ID (UID)、组 ID (GID) 及所属组信息，如果不指定用户名，则显示当前用户的信息
    * 示例: `id john`  显示 `john` 用户的用户 ID、组 ID 及所属组信息


### 其他常用命令

* **`history`**:  显示命令历史记录
    * `history`:  显示当前用户的命令历史记录，默认显示最近执行的若干条命令
    * `history N`:  显示最近执行的 N 条命令
    * `history -c`:  清空命令历史记录 (clear)
    * `!N`:  执行历史记录中第 N 条命令 (例如 `!100` 执行第 100 条命令)
    * `!!`:  执行上一条命令 (重复执行上一条命令)
    * `!关键词`:  执行最近一条以 "关键词" 开头的命令
    * `Ctrl + R`:  反向搜索命令历史记录，输入关键词可以搜索匹配的历史命令

* **`alias`**:  设置命令别名
    * `alias 别名='原命令'`:  设置命令别名，例如 `alias ll='ls -l'`，设置 `ll` 为 `ls -l` 的别名，之后可以使用 `ll` 命令代替 `ls -l`
    * `alias`:  不带参数执行 `alias` 命令，显示当前已设置的所有别名
    * `unalias 别名`:  删除指定的别名
    * 示例: `alias la='ls -la'`  设置 `la` 为 `ls -la` 的别名，用于列出所有文件 (包括隐藏文件) 的详细信息

* **`unalias`**:  取消命令别名
    * `unalias 别名`:  取消之前使用 `alias` 命令设置的别名
    * 示例: `unalias la`  取消 `la` 别名

* **`type`**:  显示命令类型
    * `type 命令名`:  显示指定命令的类型 (例如, alias, builtin, file, function 等)，以及命令的路径 (如果是文件)
    * 示例: `type ls`  显示 `ls` 命令的类型和路径

* **`which`**:  查找命令的路径
    * `which 命令名`:  查找指定命令的可执行文件路径 (仅限于在 `PATH` 环境变量中定义的目录中查找)
    * 示例: `which python3`  查找 `python3` 命令的可执行文件路径

* **`whereis`**:  查找命令的路径及相关文件
    * `whereis 命令名`:  查找指定命令的可执行文件路径、源代码路径、帮助文档路径等相关文件路径，查找范围比 `which` 更广
    * 示例: `whereis bash`  查找 `bash` 命令的可执行文件、帮助文档等路径

* **`man`**:  显示命令帮助手册 (Manual)
    * `man 命令名`:  显示指定命令的帮助手册 (manual page)，包含命令的详细用法、选项说明等，按 `q` 键退出
    * `man -k 关键词`:  根据关键词搜索相关的命令帮助手册 (keyword search)
    * 示例: `man ls`  显示 `ls` 命令的帮助手册

* **`--help`**:  大多数命令都支持 `--help` 选项，用于显示命令的简要帮助信息
    * `命令 --help`:  显示命令的简要帮助信息，通常比 `man` 手册更简洁，快速查看命令选项的用法
    * 示例: `ls --help`  显示 `ls` 命令的简要帮助信息

* **`Ctrl + C`**:  终止当前正在运行的程序或命令 (发送 SIGINT 信号)
* **`Ctrl + Z`**:  将当前正在运行的程序或命令挂起 (放到后台暂停运行，发送 SIGTSTP 信号)，可以使用 `bg` 命令放到后台继续运行，或使用 `fg` 命令放到前台继续运行
* **`Ctrl + D`**:  发送 EOF (End Of File) 信号，通常用于表示输入结束，例如在终端输入 `Ctrl + D` 可以退出 shell 会话，或在程序输入中表示输入结束。

---

希望这份整理对您有所帮助！  您可以复制上面的 Markdown 代码到任何支持 Markdown 语法的编辑器或平台 (例如 Typora, VS Code, GitHub, 博客平台等) 中，以获得更好的阅读体验和格式效果。