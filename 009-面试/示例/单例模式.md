```cpp
#include <iostream>

class Singleton {
private:
    // 私有构造函数，防止外部创建实例
    Singleton() {
        std::cout << "Singleton 实例被创建。" << std::endl;
    }

    // 静态实例指针
    static Singleton* instance;

public:
    // 静态方法，用于获取单例实例
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    // 示例方法
    void showMessage() {
        std::cout << "你好，我是单例模式的实例。" << std::endl;
    }
};

// 初始化静态实例指针
Singleton* Singleton::instance = nullptr;

int main() {
    // 获取单例实例
    Singleton* singleton1 = Singleton::getInstance();
    singleton1->showMessage();

    // 再次获取单例实例，会得到相同的实例
    Singleton* singleton2 = Singleton::getInstance();
    singleton2->showMessage();

    // 比较两个指针，它们指向同一个实例
    if (singleton1 == singleton2) {
        std::cout << "singleton1 和 singleton2 是同一个实例。" << std::endl;
    }

    return 0;
}
```

1. **私有构造函数 (`Singleton()`)**:
    
    - 构造函数被声明为 `private`，这意味着你不能从类外部直接使用 `new Singleton()` 来创建 `Singleton` 类的实例。
    - 这确保了只有类自身可以控制实例的创建。
2. **静态实例指针 (`static Singleton* instance`)**:
    
    - `instance` 是一个静态成员变量，类型为指向 `Singleton` 对象的指针。
    - `static` 关键字意味着 `instance` 属于类本身，而不是类的任何特定实例。
    - 它用于存储单例类的唯一实例的地址。
    - 在类外部初始化为 `nullptr`，表示最初没有实例。
3. **静态 `getInstance()` 方法 (`static Singleton* getInstance()`)**:
    
    - `getInstance()` 是一个公共静态方法，用于访问单例实例。
    - `static` 关键字允许你在不创建 `Singleton` 类对象的情况下调用此方法，例如 `Singleton::getInstance()`。
    - 在方法内部：
        - 它首先检查 `instance` 是否为 `nullptr`。如果是，表示还没有实例被创建。
        - 如果 `instance` 为 `nullptr`，则使用 `new Singleton()` 创建一个新的 `Singleton` 实例，并将地址赋值给 `instance`。 由于构造函数是私有的，这个 `new` 调用只能在类的内部进行。
        - 无论是否创建了新的实例，方法都会返回存储在 `instance` 中的指针，也就是单例实例的地址。
4. **示例方法 (`showMessage()`)**:
    
    - `showMessage()` 只是一个简单的示例方法，用于演示如何使用单例实例。
    - 你可以根据需要添加任何其他方法到 `Singleton` 类中。
5. **静态实例指针的初始化 (`Singleton* Singleton::instance = nullptr`)**:
    
    - 在类定义之外，必须初始化静态成员变量 `instance`。
    - `Singleton* Singleton::instance = nullptr;` 这行代码在全局作用域中为静态成员变量 `instance` 分配内存并将其初始化为 `nullptr`。

**运行结果:**

```
Singleton 实例被创建。
你好，我是单例模式的实例。
你好，我是单例模式的实例。
singleton1 和 singleton2 是同一个实例。
```

**单例模式的关键点:**

- **确保只有一个实例:** 单例模式的核心目标是限制类的实例化次数，确保系统中只有一个该类的实例存在。
- **提供全局访问点:** 单例模式提供了一个全局访问点，即 `getInstance()` 方法，让程序的任何部分都可以方便地获取到唯一的实例。
- **延迟初始化 (Lazy Initialization):** 在上面的例子中，单例实例只在第一次调用 `getInstance()` 时才被创建。这被称为延迟初始化，可以节省资源，因为在真正需要使用单例实例之前，它不会被创建。

**何时使用单例模式:**

单例模式在以下情况下很有用:

- **当类只需要一个实例时:** 例如，配置管理器、日志记录器、线程池、数据库连接池等，这些组件通常在系统中只需要一个实例来管理全局资源或状态。
- **当需要全局访问点时:** 当需要在程序的各个部分都访问同一个对象时，单例模式提供了一种方便的全局访问方式。
- **当控制共享资源时:** 单例模式可以用来控制对共享资源的访问，防止多个实例同时操作资源导致冲突。

**需要注意的地方:**

- **线程安全:** 在多线程环境中，上面的简单单例模式实现可能不是线程安全的。如果多个线程同时调用 `getInstance()`，可能会导致创建多个实例。为了线程安全，需要使用锁或其他同步机制来保护 `getInstance()` 方法。更复杂的单例模式实现通常会考虑线程安全问题。
- **过度使用:** 单例模式应该谨慎使用。过度使用单例模式可能会导致代码紧耦合，难以测试和维护。在可以使用更简单的设计模式或方法时，不应该滥用单例模式。